<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[梦幻手游部分Luac反编译失败的解决方法]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%A2%A6%E5%B9%BB%E6%89%8B%E6%B8%B8%E9%83%A8%E5%88%86Luac%E5%8F%8D%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这一篇是去年学习破解梦幻西游手游lua代码时记录的一些问题，今天将其整理并共享出来，所以不一定适合现在版本的梦幻手游，大家还是以参考为目的呗。lua相关的文章（共4篇）到此也写完了，如果以后还有新的东西会继续更新，接下来会写几篇关于2018 腾讯游戏安全竞赛的详细分析，敬请期待。 十二处bug修复&emsp;&emsp;当时反编译梦幻西游手游时遇到的问题大约有12个，修改完基本上可以完美复现lua源码，这里用的luadec5.1版本。 修复一&emsp;&emsp;问题1： 由于梦幻手游lua的opcode是被修改过的，之前的解决方案是找到梦幻的opcode，替换掉反编译工具的原opcode，并且修改opmode，再进行反编译。问题是部分测试的结果是可以的，但是当对整个手游的luac字节码反编译时，会出现各种错误，原因是luadec5.1 在很多地方都默认了opcode的顺序，并进行了特殊处理，所以需要找到这些特殊处理的地方一一修改。不过这样很麻烦，从而想到另外一种方式，不修改原来的opcode和opmode，而是在luadec解析到字节码的时候，将opcode还原成原来的opcode。 &emsp;&emsp;解决1： 定位到解析code的位置在 lundump.c –&gt; LoadFunction –&gt; LoadCode （位置不唯一，可以看上一篇腾讯比赛的修复），当执行完LoadCode函数的时候，f变量则指向了code的结构，在这之后执行自己写的函数ConvertCode函数，如下： 123456789101112// add by littleNAvoid ConvertCode(Proto *f)&#123; int pnOpTbl[] = &#123; 3,13,18,36,27,10,20,25,34,2,32,15,30,16,31,9,26,24,29,1,6,28,4,17,33,0,7,11,5,14,8,19,35,12,21,22,23,37 &#125;; for (int pc = 0; pc &lt; f-&gt;sizecode; pc++) &#123; Instruction i = f-&gt;code[pc]; OpCode o = GET_OPCODE(i); SET_OPCODE(i, pnOpTbl[o]); f-&gt;code[pc] = i; &#125;&#125; 修复二&emsp;&emsp;问题2： 在文件头部 反编译出现错误 – DECOMPILER ERROR: Overwrote pending register. &emsp;&emsp;解决2： 分析发现，原来是解析OP_VARARG错误导致的。OP_VARARG主要的作用是复制B-1个参数到A寄存器中，而反编译工具复制了B个参数，多了一个。修改后的代码如下：12345678910111213141516171819... case OP_VARARG: // Lua5.1 specific. &#123; int i; /* * Read ... into register. */ if (b==0) &#123; TRY(Assign(F, REGISTER(a), "...", a, 0, 1)); &#125; else &#123; // add by littleNA // for(i = 0;i&lt;b;i++) &#123; for(i = 0; i &lt; b-1; i++) &#123; TRY(Assign(F, REGISTER(a+i), "...", a+i, 0, 1)); &#125; &#125; break; &#125;... 修复三&emsp;&emsp;问题3： 在解析table出现反编译错误 – DECOMPILER ERROR: Confused about usage of 。registers! &emsp;&emsp;解决3： 分析发现，这里的OP_NEWTABLE 的c参数表示hash table中key的大小，而反编译代码中将c参数进行了错误转换，导致解析错误，修改代码如下： 123// add by littleNA//#define fb2int(x) (((x) &amp; 7) &lt;&lt; ((x) &gt;&gt; 3))#define fb2int(x) ((((x) &amp; 7)^8) &gt;&gt; (((x) &gt;&gt; 3)-1)) 修复四&emsp;&emsp;问题4： 反编译工具出错并且退出。 &emsp;&emsp;解决4： 跟踪发现是在AddToTable函数中，当keyed为0时会调用PrintTable，而PrintTable释放了table，下次再调用table时内存访问失败，修改代码如下： 12345678910111213141516171819202122232425void AddToTable(Function* F, DecTable * tbl, char *value, char *key)&#123; DecTableItem *item; List *type; int index; if (key == NULL) &#123; type = &amp;(tbl-&gt;numeric); index = tbl-&gt;topNumeric; tbl-&gt;topNumeric++; &#125; else &#123; type = &amp;(tbl-&gt;keyed); tbl-&gt;used++; index = 0; &#125; item = NewTableItem(value, index, key); AddToList(type, (ListItem *) item); // FIXME: should work with arrays, too // add by littleNA // if(tbl-&gt;keyedSize == tbl-&gt;used &amp;&amp; tbl-&gt;arraySize == 0)&#123; if (tbl-&gt;keyedSize != 0 &amp;&amp; tbl-&gt;keyedSize == tbl-&gt;used &amp;&amp; tbl-&gt;arraySize == 0) &#123; PrintTable(F, tbl-&gt;reg, 0); if (error) return; &#125;&#125; 修复五&emsp;&emsp; 问题5： 当函数是多值返回结果并且赋值于多个变量时反编译错误，情况如下（lua反汇编）： 1234567821 [-]: GETGLOBAL R0 K9 ; R0 := memoryStatMap22 [-]: GETGLOBAL R1 K9 ; R1 := memoryStatMap23 [-]: GETGLOBAL R2 K2 ; R2 := preload24 [-]: GETTABLE R2 R2 K3 ; R2 := R2["utils"]25 [-]: GETTABLE R2 R2 K16 ; R2 := R2["getCocosStat"]26 [-]: CALL R2 1 3 ; R2,R3 := R2()27 [-]: SETTABLE R1 K15 R3 ; R1["cocosTextureBytes"] := R328 [-]: SETTABLE R0 K14 R2 ; R0["cocosTextureCnt"] := R2 &emsp;&emsp;当上面的代码解析到27行时，从寄存器去取R3时报错，原因是前面的call返回多值时，只是在F-&gt;Rcall中进行了标记，没有在寄存器中标记，编译的结果应该为： 1memoryStatMap.cocosTextureCnt, memoryStatMap.cocosTextureBytes = preload.utils.getCocosStat() &emsp;&emsp; 解决5： 当reg为空时并且Rcall不为空，增加一个return more的标记，修改2个函数： 12345678910111213141516171819202122char *RegisterOrConstant(Function * F, int r)&#123; if (IS_CONSTANT(r)) &#123; return DecompileConstant(F-&gt;f, r - 256); // TODO: Lua5.1 specific. Should change to MSR!!! &#125; else &#123; char *copy; char *reg = GetR(F, r); if (error) return NULL; // add by littleNA // if()&#123;&#125; if (reg == NULL &amp;&amp; F-&gt;Rcall[r] != 0) &#123; reg = "return more"; &#125; copy = malloc(strlen(reg) + 1); strcpy(copy, reg); return copy; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637void OutputAssignments(Function * F)&#123; int i, srcs, size; StringBuffer *vars; StringBuffer *exps; if (!SET_IS_EMPTY(F-&gt;tpend)) return; vars = StringBuffer_new(NULL); exps = StringBuffer_new(NULL); size = SET_CTR(F-&gt;vpend); srcs = 0; for (i = 0; i &lt; size; i++) &#123; int r = F-&gt;vpend-&gt;regs[i]; if (!(r == -1 || PENDING(r))) &#123; SET_ERROR(F,"Attempted to generate an assignment, but got confused about usage of registers"); return; &#125; if (i &gt; 0) StringBuffer_prepend(vars, ", "); StringBuffer_prepend(vars, F-&gt;vpend-&gt;dests[i]); if (F-&gt;vpend-&gt;srcs[i] &amp;&amp; (srcs &gt; 0 || (srcs == 0 &amp;&amp; strcmp(F-&gt;vpend-&gt;srcs[i], "nil") != 0) || i == size-1)) &#123; // add by littleNA // if() if (strcmp(F-&gt;vpend-&gt;srcs[i], "return more") != 0) &#123; if (srcs &gt; 0) StringBuffer_prepend(exps, ", "); StringBuffer_prepend(exps, F-&gt;vpend-&gt;srcs[i]); srcs++; &#125; &#125; &#125;...&#125; 修复六&emsp;&emsp;问题6： 当函数只有一个renturn的时候会反编译错误。 &emsp;&emsp;解决6： 123456789101112131415161718 case OP_RETURN:&#123; ... // add by littleNA // 新增的if if (pc != 0) &#123; for (i = a; i &lt; limit; i++) &#123; char* istr; if (i &gt; a) StringBuffer_add(str, ", "); istr = GetR(F, i); TRY(StringBuffer_add(str, istr)); &#125; TRY(AddStatement(F, str)); &#125; break; &#125; 修复七&emsp;&emsp;问题7： 部分table初始化会出错。 &emsp;&emsp;解决7： 12345678910char *GetR(Function * F, int r)&#123; if (IS_TABLE(r)) &#123; // add by littleNA return "&#123; &#125;"; // PrintTable(F, r, 0); // if (error) return NULL; &#125;...&#125; 修复八&emsp;&emsp;问题8： 可变参数部分解析出错，但是工具反编译时是不报错误的。 &emsp;&emsp;解决8： is_vararg为7时，F-&gt;freeLocal多加了一次： 12345678910if (f-&gt;is_vararg==7) &#123; TRY(DeclareVariable(F, "arg", F-&gt;freeLocal)); F-&gt;freeLocal++;&#125;// add by littleNA// 修改if为else ifelse if ((f-&gt;is_vararg&amp;2) &amp;&amp; (functionnum!=0)) &#123; F-&gt;freeLocal++;&#125; 修复九&emsp;&emsp;问题9： 反编译工具输出的中文为url类型的字符（类似 “\230\176\148\231\150\151\230\156\175”），不是中文。 &emsp;&emsp;解决9： 在proto.c文件中的DecompileString函数中，注释掉default 转换字符串的函数： 123456789101112131415char *DecompileString(const Proto * f, int n)&#123;... default: //add by littleNA// if (*s &lt; 32 || *s &gt; 127) &#123;// char* pos = &amp;(ret[p]);// sprintf(pos, "\\%d", *s);// p += strlen(pos);// &#125; else &#123; ret[p++] = *s;// &#125; break;...&#125; &emsp;&emsp;然后再下面3处增加判断的约束条件，因为中文字符的话，char字节是负数，这样isalpha和isalnum函数就会出错，所以增加约束条件，小于等于127： 12345678910111213141516171819202122232425262728293031323334353637383940void MakeIndex(Function * F, StringBuffer * str, char* rstr, int self)&#123;... int dot = 0; /* * see if index can be expressed without quotes */ if (rstr[0] == '\"') &#123; // add by littleNA // (unsigned char)(rstr[1]) &lt;= 127 &amp;&amp; if ((unsigned char)(rstr[1]) &lt;= 127 &amp;&amp; isalpha(rstr[1]) || rstr[1] == '_') &#123; char *at = rstr + 1; dot = 1; while (*at != '"') &#123; // add by littleNA // *(unsigned char*)at &lt;= 127 &amp;&amp; if (*(unsigned char*)at &lt;= 127 &amp;&amp; !isalnum(*at) &amp;&amp; *at != '_') &#123; dot = 0; break; &#125; at++; &#125; &#125; &#125;....&#125;... case OP_TAILCALL: &#123; // add by littleNA // (unsigned char)(*at) &lt;= 127 &amp;&amp; while (at &gt; astr &amp;&amp; ((unsigned char)(*at) &lt;= 127 &amp;&amp; isalpha(*at) || *at == '_')) &#123; at--; &#125; &#125;... 修复十&emsp;&emsp;问题10： 反汇编失败。因为一些文件中含有很长的字符串，导致sprintf函数调用失败。 &emsp;&emsp;解决10： 增加缓存的大小： 1234567void luaU_disassemble(const Proto* fwork, int dflag, int functions, char* name) &#123; ... // add by littleNA // char lend[MAXCONSTSIZE+128]; char lend[MAXCONSTSIZE+2048];...&#125; 修复十一&emsp;&emsp;问题11： op_setlist操作码当b==0时，反编译失败。 &emsp;&emsp;解决11： 当遇到类似下面的lua语句时，反编译工具会失败，出现的情况在@lib_ui.lua文件中： 1local a=&#123;func()&#125; &emsp;&emsp;汇编后的代码： 123456 a b c[1] newtable 0 0 0 ; array=0, hash=0[2] getglobal 1 0 ; func[3] call 1 1 0[4] setlist 0 0 1 ; index 1 to top[5] return 0 1 &emsp;&emsp;出现的问题有2处，第一个是newtable，当b == 0 &amp;&amp; c == 0时，反编译工具认为table是空的table，直接输出了table并且释放了table的内存，导致后面setlist初始化table时找不到内存而报错。 &emsp;&emsp;第二个是setlist有问题，当b==0时，其实是指寄存器a+1到栈顶（top）的值全部赋值于table，而反编译器没有对b==0的判断，加上就可以了。所以修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void StartTable(Function * F, int r, int b, int c)&#123; DecTable *tbl = NewTable(r, F, b, c); AddToList(&amp;(F-&gt;tables), (ListItem *) tbl); F-&gt;Rtabl[r] = 1; F-&gt;Rtabl[r] = 1; if (b == 0 &amp;&amp; c == 0) &#123; // add by littleNA // for()&#123;&#125; for (int npc = F-&gt;pc + 1; npc &lt; F-&gt;f-&gt;sizecode; npc++) &#123; Instruction i = F-&gt;f-&gt;code[npc]; OpCode o = GET_OPCODE(i); if ((o != OP_SETLIST &amp;&amp; o != OP_SETTABLE) &amp;&amp; r == GETARG_A(i)) &#123; PrintTable(F, r, 1); return; &#125; else if ((o == OP_SETLIST || o == OP_SETTABLE) &amp;&amp; r == GETARG_A(i)) &#123; return; &#125; &#125; PrintTable(F, r, 1); if (error) return; &#125;&#125;void SetList(Function * F, int a, int b, int c)&#123;... // add by littleNA // if()&#123;&#125; if (b == 0) &#123; Instruction i = F-&gt;f-&gt;code[F-&gt;pc-1]; OpCode o = GET_OPCODE(i); if (o == OP_CALL) &#123; int aa = GETARG_A(i); for (i = a + 1; i &lt; aa + 1; i++) &#123; char* rstr = GetR(F, i); if (error) return; AddToTable(F, tbl, rstr, NULL); if (error) return; &#125; &#125; else &#123; for (i = 1;;i++) &#123; char* rstr = GetR(F, a + i); if (rstr == NULL) return; AddToTable(F, tbl, rstr, NULL); if (error) return; &#125; &#125; &#125;...&#125; &emsp;&emsp;StartTable 增加的for循环表示，如果执行了newtable(r 0 0)，后面非初始化table的操作覆盖了r寄存器（把table覆盖了），那就表明new出来的table是空的，后面没有对table的赋值；如果后面有对r寄存器初始化，证明此时new出了的table不是空的，是可变参数的table。 &emsp;&emsp;SetList 增加的if表示，如果指令是call指令，那么将a+1到call指令寄存器aa的栈元素加入到table中（这里为何不是到栈顶的元素而是到aa的元素呢？因为call指令对应的是函数调用，反编译工具已经把函数调用的字符串解析到aa中了，这里跟实际运行可能有点不一样；else后面就是将a+1到栈顶的元素初始化到table中，直到GetR函数为空表示到栈顶了。 修复十二&emsp;&emsp;问题12： 当一个函数开头只是局部变量声明，如： 12345function func() local a,b,c c = f(a,b) return cend &emsp;&emsp;第一行 local a,b,c 会反编译失败，导致后面的代码出现各种错误。 &emsp;&emsp;解决12： 1234567891011121314151617181920void DeclareLocals(Function * F)&#123;... for (i = startparams; i &lt; F-&gt;f-&gt;sizelocvars; i++) &#123; if (F-&gt;f-&gt;locvars[i].startpc == F-&gt;pc) &#123; ... if (PENDING(r)) &#123;...&#125; // add by littleNA // else if()&#123;&#125; else if (locals == 0 &amp;&amp; F-&gt;pc == 0) &#123; StringBuffer_add(str, LOCAL(i)); char *szR = GetR(F, r); StringBuffer_add(rhs, szR==NULL?"nil":szR); &#125; ... &#125; &#125;...&#125; &emsp;&emsp;当变量的startpc 等于 当前pc，变量的个数为0并且当前pc为0，表示第一行声明了变量，添加的else if就是解析这种情况的（原来是直接报错不解析）。 &emsp;&emsp;（完）]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>手游安全</tag>
        <tag>luac反编译</tag>
        <tag>梦幻西游手游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密（后续）]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%EF%BC%88%E5%90%8E%E7%BB%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;趁着周末，把lua的后续文章也写完了。 反编译对抗&emsp;&emsp;众所周知，反汇编/反编译 工具在逆向人员工作中第一步被使用，其地位非常之高，而对于软件保护者来说，如何对抗 反汇编/反编译 就显得尤为重要。例如，动态调试中对OD的的检测、内核调试对windbg的破坏、加壳加花对IDA静态分析的阻碍、apktool的bug导致对修改后的apk反编译失败、修改PE头导致OD无法识别、修改 .Net dll中的区段导致ILspy工具失效等等例子，都说明对抗反编译工具是很常用的一种软件保护手段，当然lua的反编译工具也面临这个问题。处理这样的问题无非就几种思路： 用调试器调试反编译工具为何解析错误，排查原因。 用调试器调试原引擎是如何解析文件的。 用文件格式解析工具解析文件，看哪个点解析出错。 &emsp;&emsp;下面将以3个例子来实战lua反编译是如何对抗与修复。 例子1：一个简单的问题&emsp;&emsp;这是在看雪论坛看到的一个问题，问题是由于游戏（可能是征途手游）将lua字符串的长度int32修改为int64，导致反编译失败的一个例子，修复方法请看帖子中本人的回答，地址：https://bbs.pediy.com/thread-217033.htm 例子2：2018腾讯游戏安全竞赛&emsp;&emsp;这一节以2018腾讯游戏安全竞赛决赛第二题进阶版第1关的题目为例子，主要是讲一下如何修复当lua的opcode被修改的情况，以及如何修复该题对抗lua反编译的问题。 opcode问题及其修复&emsp;&emsp;修复opcode的目的是 当输入题目的luac文件，反汇编工具Chunkspy和反编译工具luadec能够输出正确的结果。 &emsp;&emsp;首先，我们在ida中分析lua引擎tmgs.dll文件，然后定位到luaV_execute函数（搜索字符串“ ‘for’ limit must be a number ”），发现switch下的case的参数（lua的opcode）是乱序的，到这里我们就能够确认，该题的lua虚拟机opcode被修改了。 &emsp;&emsp;接着，我们进行修复操作。一种很耗时的办法就是一个一个opcode还原，分析每一个case下面的代码然后找出对应opcode的顺序。但是这一题我们不用这么麻烦，通过对比分析我们发现普通版的题目并没有修改opcode： 普通版lua引擎的luaV_execute函数 进阶版lua引擎的luaV_execute函数 &emsp;&emsp;观察发现，进阶版的题目只是修改了每个case的数值或者多个值映射到同一个opcode，但是没有打乱case里的代码（也就是说，虚拟机解析opcode代码的顺序没有变，只是修改了对应的数值，这跟梦幻手游的打乱opcode的方法不同）。由于lua5.3只使用到0x2D的opcode，而一个opcode长度为6位（0x3F），该题就将剩余的没有使用的字节映射到同一个opcode下，修复时只需要反过来操作就可以了。分析到这里，我们的修复方案就出来了： 通过ida分别导出2个版本的 luaV_execute 的文本 通过python脚本提取opcode的修复表 在工具（Chunkspy和luadec）初始化lua文件后，用修复表将opcode替换 测试运行，修复其他bug &emsp;&emsp;第一步直接IDA手动导出: File –&gt; Produce file –&gt; Create LST File ；第二步使用python分析，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# 通过扫码IDA导出的文本文件，获取lua字节码的opcode顺序def get_opcode(filepath): f = open(filepath) lines = f.readlines() opcodes = [] # 循环扫码文件的每一行 for i in range(len(lines)): line = lines[i] if line.find('case') != -1: line = line.replace('case', '') line = line.replace(' ', '') line = line.replace('\n','') line = line.replace('u:', '') # 如果上一行也是case，那么这2个case对应同一个opcode if lines[i-1].find('case') != -1: opcode = opcodes[-1] opcode.append(line) else: opcode = [] opcode.append(line) opcodes.append(opcode) f.close() return opcodeso1 = get_opcode(u'基础版opcode.txt')o2 = get_opcode(u'进阶版opcode.txt')# 还原for i in range(len(o1)): print '基础版：',o1[i],'\t进阶版：',o2[i]# 映射opcode获取修复表op_tbl = [-1 for i in range(64)]for i in range(len(o1)): o1opcode = o1[i][0] o1opcode = o1opcode.replace('0x','') for o2opcode in o2[i]: o2opcode = o2opcode.replace('0x','') op_tbl[int(o2opcode,16)] = int(o1opcode,16)print '修复表：',op_tbl &emsp;&emsp;运行结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647基础版： ['0'] 进阶版： ['6', '7', '0x16', '0x1B']基础版： ['1'] 进阶版： ['0x22', '0x28', '0x29', '0x3C']基础版： ['2'] 进阶版： ['0x3E']基础版： ['3'] 进阶版： ['0x3B']基础版： ['4'] 进阶版： ['0x12']基础版： ['5'] 进阶版： ['8', '0x11', '0x17', '0x36']基础版： ['6'] 进阶版： ['2']基础版： ['7'] 进阶版： ['0xD']基础版： ['8'] 进阶版： ['0x1A']基础版： ['9'] 进阶版： ['1']基础版： ['0xA'] 进阶版： ['0x1D']基础版： ['0xB'] 进阶版： ['0x1F']基础版： ['0xC'] 进阶版： ['0xE']基础版： ['0xD'] 进阶版： ['0x31']基础版： ['0xE'] 进阶版： ['0x2F']基础版： ['0xF'] 进阶版： ['0x1E']基础版： ['0x12'] 进阶版： ['0x13']基础版： ['0x14'] 进阶版： ['0x2B']基础版： ['0x15'] 进阶版： ['0x1C']基础版： ['0x16'] 进阶版： ['0x2D']基础版： ['0x17'] 进阶版： ['0x19']基础版： ['0x18'] 进阶版： ['0x3F']基础版： ['0x10'] 进阶版： ['0x15']基础版： ['0x13'] 进阶版： ['0x24']基础版： ['0x11'] 进阶版： ['0x3A']基础版： ['0x19'] 进阶版： ['0x18']基础版： ['0x1A'] 进阶版： ['0x33']基础版： ['0x1B'] 进阶版： ['0xF']基础版： ['0x1C'] 进阶版： ['0x34']基础版： ['0x1D'] 进阶版： ['0x20']基础版： ['0x1E'] 进阶版： ['5', '9', '0xA', '0x25']基础版： ['0x1F'] 进阶版： ['0x30']基础版： ['0x20'] 进阶版： ['0x26']基础版： ['0x21'] 进阶版： ['0x35']基础版： ['0x22'] 进阶版： ['0x38']基础版： ['0x23'] 进阶版： ['0x2A']基础版： ['0x24'] 进阶版： ['0x23', '0x37', '0x39', '0x3D']基础版： ['0x25'] 进阶版： ['0x27']基础版： ['0x27'] 进阶版： ['0x2C']基础版： ['0x28'] 进阶版： ['0x32']基础版： ['0x29'] 进阶版： ['0x21']基础版： ['0x2A'] 进阶版： ['3']基础版： ['0x2B'] 进阶版： ['0xC']基础版： ['0x2C'] 进阶版： ['0x2E']基础版： ['0x2D'] 进阶版： ['0x14']基础版： ['0x26'] 进阶版： ['4']修复表： [-1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24] &emsp;&emsp;注意了，这里有几个opcode是没有对应关系的（默认是-1），跟踪代码发现，其实这些opcode的功能相当于nop操作，而原本lua是不存在nop的，我们只需在修复的过程中跳过这个字节码即可。 &emsp;&emsp;最后将获取的修复表替换到工具中，Chunspy修复点在DecodeInst函数中，修改结果如下：12345678910111213141516171819202122232425262728293031323334353637383940function DecodeInst(code, iValues) local iSeq, iMask = config.iABC, config.mABC local cValue, cBits, cPos = 0, 0, 1 -- decode an instruction for i = 1, #iSeq do -- if need more bits, suck in a byte at a time while cBits &lt; iSeq[i] do cValue = string.byte(code, cPos) * (1 &lt;&lt; cBits) + cValue cPos = cPos + 1; cBits = cBits + 8 end -- extract and set an instruction field iValues[config.nABC[i]] = cValue % iMask[i] cValue = cValue // iMask[i] cBits = cBits - iSeq[i] end -- add by littleNA local optbl = &#123; -1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24 &#125; iValues.OP = optbl[iValues.OP+1] -- 注意，lua的下标是从1开始的数起的 -- add by littleNA end iValues.opname = config.opnames[iValues.OP] -- get mnemonic iValues.opmode = config.opmode[iValues.OP] -- add by littleNA if iValues.OP == -1 then iValues.opname = "Nop" iValues.opmode = iABx end -- add by littleNA end if iValues.opmode == iABx then -- set Bx or sBx iValues.Bx = iValues.B * iMask[3] + iValues.C elseif iValues.opmode == iAsBx then iValues.sBx = iValues.B * iMask[3] + iValues.C - config.MAXARG_sBx elseif iValues.opmode == iAx then iValues.Ax = iValues.B * iMask[3] * iMask[2] + iValues.C * iMask[2] + iValues.A end return iValuesend &emsp;&emsp;测试发现出错了，出错结果： &emsp;&emsp;从出错的结果可以看出是luac文件的版本号有错误，这里无法识别lua 11的版本其实是题目故意设计让工具识别错误，我们将文件的第4个字节（lua版本号）11修改成53就可以了。正确结果： &emsp;&emsp;luadec修复点在ldo.c文件的f_parser函数，并且增加一个RepairOpcode函数，修复如下：1234567891011121314151617181920212223242526272829303132333435363738394041// add by littleNAvoid RepairOpcode(Proto* f)&#123; // opcode 替换表 char optbl[] = &#123; -1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24 &#125;; for (int i = 0; i &lt; f-&gt;sizecode; i++) &#123; Instruction code = f-&gt;code[i]; OpCode o = GET_OPCODE(code); SET_OPCODE(code, optbl[o]); f-&gt;code[i] = code; &#125; for (int i = 0; i &lt; f-&gt;sizep; i++) &#123;// 处理子函数 RepairOpcode(f-&gt;p[i]); &#125;&#125;// add by littleNA endstatic void f_parser (lua_State *L, void *ud) &#123; LClosure *cl; struct SParser *p = cast(struct SParser *, ud); int c = zgetc(p-&gt;z); /* read first character */ if (c == LUA_SIGNATURE[0]) &#123; checkmode(L, p-&gt;mode, "binary"); cl = luaU_undump(L, p-&gt;z, p-&gt;name); // add by littleNA Proto *f = cl-&gt;p; RepairOpcode(f); // add by littleNA end &#125; else &#123; checkmode(L, p-&gt;mode, "text"); cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c); &#125; lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues); luaF_initupvals(L, cl);&#125; &emsp;&emsp;运行一下，发现出错了，并且停留在StringBuffer_add函数中，其中str指向错误的地方，导致字符串读取出错： &emsp;&emsp;到这里我们修复了opcode，并且Chunkspy顺利反汇编，但是luadec的反编译还是有问题，我们在下一节分析。 反编译问题及其修复&emsp;&emsp;看了几个大佬的writeup，发现他们都没有修复这个问题，解题过程中都是直接分析的是lua汇编代码。我们看看出错的原因，查看vs的调用堆栈： &emsp;&emsp;发现上一层函数是listUpvalues函数，也就是说luadec在解析upvalues时出错了，深入分析发现其实是由于文件中的upvalue变量名被抹掉了，导致解析出错，我们只需要在ProcessCode函数（decompile.c文件）调用listUpvalues函数前，增加临时的upvalue命名就可以了，修改代码如下： 123456789101112131415161718char* ProcessCode(Proto* f, int indent, int func_checking, char* funcnumstr) &#123;... // make function comment StringBuffer_printf(str, "-- function num : %s", funcnumstr); if (NUPS(f) &gt; 0) &#123; // add by littleNA for (i = 0; i&lt;f-&gt;sizeupvalues; i++) &#123; char tmp[10]; sprintf(tmp, "up_%d", i); f-&gt;upvalues[i].name = luaS_new(f-&gt;L, tmp); &#125; // add by littleNA end StringBuffer_add(str, " , upvalues : "); listUpvalues(f, str); &#125;...&#125; &emsp;&emsp;最后完美运行luadec，反编译成功。 例子3：梦幻西游手游&emsp;&emsp;这个例子内容较多，并且这篇文章也够长了，索性就把这节单独写成一篇文章。]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密（前传）]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%EF%BC%88%E5%89%8D%E4%BC%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;为了能让一些同学更好的学习lua的逆向，我把收集的一些资料组合成一篇lua加解密的相关工作给大家参考，当然，看这篇文章之前还是需要一些lua的基础知识，这里推荐云风大佬的《Lua源码欣赏》[19]，建议结合搜索引擎学习之。 &emsp;&emsp;文章分2部分介绍，第1部分介绍lua加解密的相关文章介绍，第2部分介绍lua的相关工具。 相关工作：&emsp;&emsp;这一节介绍了互联网上对lua的各种相关文章，包括lua的加解密如文件格式的解析、基于lua的游戏和比赛的介绍、lua的hook技术等。 1. lua加解密入门： &emsp;&emsp;非虫大佬[1-4] 写了4篇关于luac和luajit文件格式和字节码的相关文章，并开源了010Editor的解析luac和luajit的模板代码。Ganlv 同学[7] 在吾爱破解写了7篇关于lua加解密的系列教程。腾讯gslab[9] 写了一篇关于lua游戏逆向的入门介绍，这是一篇比较早的lua游戏解密的文章。INightElf 同学[10] 写了一篇关于lua脚本反编译入门的文章。 2. 基于lua的手游： &emsp;&emsp;lua不仅能用于端游戏，也能用于手游，而且由于手游的火热，带动了lua逆向相关分析文章的分享。wmsuper 同学[11] 在android平台下解密了腾讯游戏开心消消乐的lua脚本，后续可以通过修改lua脚本达到作弊的目的。Unity 同学[8] 通过hook的方法解密和修改lua手游《放置江湖》的流程，达到修改游戏奖励的目的。littleNA 同学[12] 通过3种方式解密了3个手游的lua脚本，并且修复了梦幻手游lua opcode的顺序。 3. 基于lua的比赛： &emsp;&emsp;随着国内CTF的发展，lua技术也运用到了比赛中。看雪ctf2016第2题[13]、2017第15题[14]和腾讯游戏安全2018决赛第2题[15]都使用了lua引擎作为载体的CrackMe比赛，其中看雪2016将算法验证用lua代码实现并编译成luac，最后还修改了luac的文件头，使得反编译工具报错；看雪2017的题使用壳和大量的混淆，最后一步是luajit的简单异或运算；腾讯2018使用的lua技术更加深入，进阶版更是修改了lua的opcode顺序，并使用lua编写了一个虚拟机。以上3题的writeup网上都可以搜索到，有兴趣的朋友可以练练手，加深印象。 4. lua hooking： &emsp;&emsp;Hook是修改软件流程的常用手段，lua中也存在hook技术。曾半仙 同学[9] 在看雪发布了一种通过hook lua字节码达到修改游戏逻辑的方法，并发布了一个lua汇编引擎。Nikc Cano[5] 的blog写了一篇关于Hooking luajit的文章，興趣使然的小胃 同学[6] 对该篇文章进行了翻译。 工具介绍：&emsp;&emsp;逆向解密lua和luajit游戏都有相关的工具，这一节将对一些主流的工具进行介绍。 1. lua相关： luadec [16]：这是一个用c语言结合lua引擎源码写的开源lua反编译器，解析整个lua字节码文件并尽可能的还原为源码。当然，由于还原的是高级语言，所以兼容性一般，当反编译大量文件时肯定会遇到bug，这时就需要自己手动修复bug；并且很容易被针对造成反编译失败。目前支持的版本有lua5.1、，5.2和5.3。 chunkspy：一款非常有用的lua分析工具，本身就是lua语言所写。它解析了整个lua字节文件，由于其输出的是lua的汇编形式，所以兼容性非常高，也造成了一定的阅读障碍。chunklua 不仅可以解析luac文件，它还包括了一个交互式的命令，可以将输入的lua脚本转换成lua字节码汇编的形式，这对学习lua字节码非常有帮助。luadec工具中集成了这个脚本，目前支持的版本也是有lua5.1，5.2和5.3。 unluac：这也是一个开源的lua反编译器，java语言所写，相比luadec 工具兼容性更低,。一般很少使用，只支持lua5.1，当上面工具都失效时可以尝试。 2. luajit相关： luajit-decomp[17]：github开源的一款luajit反编译工具，使用au3语言编写。先通过luajit原生的exe文件将luajit字节码文件转换成汇编，然后该工具再将luajit汇编转换成lua语言。由于反汇编后的luajit字节码缺少很多信息，如变量名、函数名等，造成反编译后的结果读起来比较隐晦，类似于ida的F5。但是兼容性超好，只要能够反汇编就能够反编译，所以需要找到待反编译的luajit文件对于的luajit引擎的版本。目前是支持所有的luajit版本。 ljd[18]：也是github开源的一款luajit反编译工具，使用python编写，与luajit-decomp 反编译luajit汇编的方式不同，其从头解析了整个luajit文件，能够获取更多的信息，还原的程度更高，但是由于精度更高，所以兼容性也会弱一点。查看该项目的fork可以获取更多的其他兼容版本，目前支持的版本有luajit2.0、luajit2.1等。 参考文章 [1] 飞虫 《Lua程序逆向之Luac文件格式分析》 https://www.anquanke.com/post/id/87006 [2] 飞虫 《Lua程序逆向之Luac字节码与反汇编》 https://www.anquanke.com/post/id/87262 [3] 飞虫 《Lua程序逆向之Luajit文件格式》 https://www.anquanke.com/post/id/87281 [4] 飞虫 《Lua程序逆向之Luajit字节码与反汇编》 https://www.anquanke.com/post/id/90241 [5] Nick Cano 《Hooking LuaJIT》 https://nickcano.com/hooking-luajit [6] 興趣使然的小胃 《看我如何通过hook攻击LuaJIT》 https://www.anquanke.com/post/id/86958 [7] Ganlv 《lua脚本解密1：loadstring》 https://www.52pojie.cn/thread-694364-1-1.html [8] unity 《【放置江湖】LUA手游 基于HOOK 解密修改流程》 https://www.52pojie.cn/thread-682778-1-1.html [9] 游戏安全实验室 《Lua游戏逆向及破解方法介绍》 http://gslab.qq.com/portal.php?mod=view&amp;aid=173 [10] INightElf 《[原创]Lua脚本反编译入门之一》 https://bbs.pediy.com/thread-186530.htm [11] wmsuper 《开心消消乐lua脚本解密》 https://www.52pojie.cn/thread-611248-1-1.html [12] littleNA 《浅析android手游lua脚本的加密与解密》 https://bbs.pediy.com/thread-216969.htm [13] 《看雪 2016CrackMe 第二题》 https://ctf.pediy.com/game-fight-3.htm [14] 《看雪 2017CrackMe 第十五题》 https://ctf.pediy.com/game-fight-45.htm [15] 《腾讯游戏安全技术竞赛》 https://www.52pojie.cn/forum-77-1.html [16] luadec https://github.com/viruscamp/luadec [17] ljd https://github.com/NightNord/ljd [18] luajit-decomp https://github.com/bobsayshilol/luajit-decomp [19] 云风 《Lua源码欣赏》 https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/luadec/云风-lua源码欣赏-lua-5.2.pdf]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;博客刚刚弄完善，把去年发在看雪的一篇精华帖转了过来，文章稍微修改了下，并且增加了后续文章，希望能够吸引点人气。这篇文章是我在学习android手游安全时总结的一篇关于lua的文章，不足之处欢迎指正，也欢迎各位大佬前来交流。 &emsp;&emsp;主要用到的工具和环境： win7系统 cocos2d-x 开发环境 IDA6.8 vs2015 AndroidKiller 1.3.1 luadec51 luajit-decomp… lua 现状分析&emsp;&emsp;去年的那篇文章这一章没有写的，今年补上了一篇lua加解密的相关工作，请看：《浅析android手游lua脚本的加密与解密（前传）》 lua 各文件关系&emsp;&emsp;在学习lua手游解密过程中，遇到的lua文件不外乎就3种。其中.lua后缀的文件是明文代码，直接用记事本就能打开，.luac是lua脚本编译后的字节码文件，文件头为0x1B 0x4C 0x75 0x61，lua虚拟机能够直接解析lua和luac脚本文件，而.luaJIT是另一个lua的实现版本（不是lua的原作者写的），JIT是指Just-In-Time（即时解析运行），luaJIT相比lua和luac更加高效，文件头是0x1B 0x4C 0x4A： &emsp;&emsp;luac 文件头如下： &emsp;&emsp;luaJIT 文件头如下： lua 脚本保护&emsp;&emsp;一般有安全意识的游戏厂商都不会直接把lua源码脚本打包到APK中发布，所以一般对lua脚本的保护有下面3种： 1. 普通的对称加密，在加载脚本之前解密 &emsp;&emsp;这种情况是指打包在APK中的lua代码是加密过的，程序在加载lua脚本时解密（加载脚本的关键函数luaL_loadbuffer），解密后就能够获取lua源码。如果解密后获取的是luac字节码的话，也可以通过对应的反编译得到lua源码，反编译主要用的工具有unluac和luadec51，后面会具体分析。 2. 将lua脚本编译成luaJIT字节码并且加密打包 &emsp;&emsp;因为cocos2d-x使用的luaJIT，而且luaJIT反编译后的结果阅读起来比较麻烦，所以这种情况能够较好的保护lua源码。这个情况主要是先解密后反编译，反编译主要是通过luajit-decomp项目，它能够将luajit字节码反编译成伪lua代码。 3. 修改lua虚拟机中opcode的顺序 &emsp;&emsp;这种情况主要是修改lua虚拟机源码，再通过修改过的虚拟机将lua脚本编译成luac字节码，达到保护的目的。这种情况如果直接用上面的反编译工具是不能将luac反编译的，需要在虚拟机的引擎中分析出相对应的opcode，然后修复反编译工具luadec 源码中的 opcode 并重新编译，编译后的文件就能进行反编译了，后面会具体分析。 &emsp;&emsp;在破解手游过程中，上面的三种情况可能会交叉遇到。 获取lua源码的一般方法&emsp;&emsp;这里主要介绍4种方法，都会在后面用实例说明。 1. 静态分析so解密方法 &emsp;&emsp;这种方法需要把解密的过程全部分析出来，比较费时费力，主要是通过ida定位到luaL_loadbuffer函数，然后往上回溯，分析出解密的过程。 2. 动态调试：ida + idc + dump &emsp;&emsp;游戏会在启动的时候通过调用 luaL_loadbuffer函数加载必要的lua脚本，我们可以通过ida动态调试so文件，然后是定位到luaL_loadbuffer地址，再下断点 ，断下后就接着运行idc脚本（或者python脚本）将lua代码导出（程序调用一次luaL_loadbuffer只加载一个lua脚本，所以需要编写idc脚本自动保存lua代码）。 3. hook so &emsp;&emsp;跟4.2原理一样，就是通过hook函数luaL_loadbuffer地址，将lua代码保存，相比4.2的好处是有些lua脚本需要在玩游戏的过程中才加载，如果用了4.2的方法，那么在游戏过程中需要加载新的lua文件就会中断一次，我们就需要手动运行一次idc脚本，如果是hook的话，就不需要那么麻烦，直接玩一遍游戏，全部lua脚本就已经保存好了。 4. 分析lua虚拟机的opcode的顺序 &emsp;&emsp;这里主要是opcode的顺序被修改了，需要用ida定位到虚拟机执行luac字节码的地方，然后对比原来lua虚拟机的执行过程，获取修改后的opcode顺序，最后还原lua脚本。 &emsp;&emsp;综上，静态分析费时费力但是能够解密全部的lua脚本，而通过动态获取的方法虽然方便，但是只能获取游戏当前需要加载的lua脚本。具体选择哪种方法，需要衡量时间成本等。 lua脚本解密实例分析&emsp;&emsp;接着用3个游戏作为实例说明上面分析的情况。 54捕鱼&emsp;&emsp;首先用AndroidKiller 加载，然后查看lib目录下的so文件，发现libcocos2dlua.so文件，基本可以确定是lua脚本编写的了。这里有个小技巧，当有很多so文件的时候，一般最大的文件是我们的目标（文件大是因为集成了lua引擎，既然有lua引擎，那么肯定有lua脚本了）。接着找lua脚本，资源文件和lua脚本文件都是在assets目录下。我们发现这个游戏的资源文件和配置文件都是明文，这里直接修改游戏的配置文件就可以作弊（比如修改升级炮台所需的金币和钻石，就可以达到快速升级炮台的目的），然后并没有发现类似lua脚本的文件。 &emsp;&emsp;顺手解压了一下res目录下的liveupdate_precompiled.zip，发现解压失败，看来是加密了（看文件名字知道是更新游戏的代码）这里说明一下，一般遇到xxxx_precompiled.zip的这种文件，都是quick-cocos2d-x框架（quick简单来说就是对lua的拓展实现），在quick-cocos2d-x框架下可以用compile_scripts命令将lua文件加密打包成xxxx_precompiled.zip，游戏运行时再解密加载。注意，这种方式打包的lua脚本一般都会被编译成luaJIT字节码，加载的关键函数是loadChunksFromZIP，可以在IDA中直接搜索该函数，如果找不到可以搜索字符串luaLoadChunksFromZIP来定位到函数 &emsp;&emsp;OK，了解了原理接下来开始动手分析，将libcocos2dlua.so拖到IDA中加载，函数中直接搜索loadChunksFromZIP，定位后F5分析。 &emsp;&emsp;对该函数一直向上回溯（交叉引用 ），来到下图，发现解密的密钥和签名，其中xiaoxian为密钥，XXFISH为签名 &emsp;&emsp;进去函数里面看看，其实会发现调用了XXTea算法，这里我们也可以直接分析loadChunksFromZIP函数的源码（所以配置一个cocos2d的开发环境还是非常有必要的）。查看源码里的lua_loadChunksFromZIP函数的原型：12345678910111213141516171819202122232425int CCLuaStack::lua_loadChunksFromZIP(lua_State *L)&#123; if (lua_gettop(L) &lt; 1) &#123; // 这里可以发现用字符串也可以定位到目标函数 CCLOG("lua_loadChunksFromZIP() - invalid arguments"); return 0; &#125;... if (isXXTEA) &#123; // decrypt XXTEA // 这里调用了解密函数 xxtea_long len = 0; buffer = xxtea_decrypt(zipFileData + stack-&gt;m_xxteaSignLen, (xxtea_long)size - (xxtea_long)stack-&gt;m_xxteaSignLen, (unsigned char*)stack-&gt;m_xxteaKey, (xxtea_long)stack-&gt;m_xxteaKeyLen, &amp;len); delete []zipFileData; zipFileData = NULL; zip = CCZipFile::createWithBuffer(buffer, len); &#125;...&#125; &emsp;&emsp;接下来直接写解密函数（在cocos2d-x项目里面写的解密函数，很多工具类直接可以调用）12345678910111213141516171819202122232425262728293031323334353637383940void decryptZipFile_54BY(string strZipFilePath)&#123; CCFileUtils *utils = CCFileUtils::sharedFileUtils(); unsigned long lZipFileSize = 0; unsigned char *szBuffer = NULL; unsigned char *zipFileData = utils-&gt;getFileData(strZipFilePath.c_str(), "rb", &amp;lZipFileSize); xxtea_long xxBufferLen = 0; szBuffer = xxtea_decrypt(zipFileData + 6, //6为签名XXFISH的长度 (xxtea_long)lZipFileSize - (xxtea_long)6, //减去签名的长度 (unsigned char*)"xiaoxian", //xiaoxian为密钥 (xxtea_long)8, //密钥的长度 &amp;xxBufferLen); //获取zip里面的所有文件 CCZipFile *zipFile = CCZipFile::createWithBuffer(szBuffer, xxBufferLen); int count = 0; string strFileName = zipFile-&gt;getFirstFilename(); while (strFileName.length()) &#123; cout &lt;&lt; "filename:" &lt;&lt; strFileName &lt;&lt; endl; unsigned long lFileBufferSize = 0; unsigned char *szFileBuffer = zipFile-&gt;getFileData(strFileName.c_str(), &amp;lFileBufferSize); if (lFileBufferSize) &#123; ++count; ofstream ffout(strFileName, ios::binary); ffout.write((char *)szFileBuffer, sizeof(char) * (lFileBufferSize)); ffout.close(); delete[] szFileBuffer; &#125; strFileName = zipFile-&gt;getNextFilename(); &#125; delete[] zipFileData;&#125; &emsp;&emsp;解密后的文件如下： &emsp;&emsp;这几个都是更新游戏的代码，是luajit的文件，所以接下来需要反编译。反编译需要确定lua和luajit的版本，我们通过IDA查看下lua版本和luajit版本，字符串中分别搜索lua+空格和luajit+空格： &emsp;&emsp;lua版本为5.1 &emsp;&emsp;luajit版本为2.1.0 &emsp;&emsp;这篇文章反编译用到的是luajit-decomp，这里需要注意，luajit-decomp默认的lua 5.1 和luajit 2.0.2，我们需要下载对应lua和luajit的版本，编译后替换luajit-decomp下的lua51.dll、luajit.exe、jit文件夹。反编译时需要替换的文件和文件夹如下： &emsp;&emsp;对于这个游戏，我们需要下载版本为2.1.0-beta2的luajit，并且编译生成文件后，复制LuaJIT-2.1.0-beta2\src路径下的lua51.dll、luajit.exe文件和jit文件夹覆盖到luajit-decomp目录中。luajit-decomp用的是autolt3语言，原脚本默认是只反编译当前目录下的test.lua文件，所以需要修改decoder.au3文件的代码。修改后的代码另存为jitdecomp.au3文件，接着编译au3代码为jitdecomp.exe。我这里还增加了data目录，该目录下有3个文件夹，分别为： luajit：待反编译的luajit文件 asm：反汇编后的中间结果 out：反编译后的结果 &emsp;&emsp;将解密后的文件放到luajit文件夹，运行 jitdecomp.exe，反编译的结果在out目录下，结果如下： &emsp;&emsp;这个反编译工具写得并不好，反编译后的lua文件阅读起来相对比较困难，而且反编译的lua格式有问题，所以不能用lua编辑器格式化代码。 捕鱼达人4&emsp;&emsp;这个游戏主要是用ida动态调试so文件，然后用idc脚本把lua文件全部dump下来的方法。首先用AndroidKiller加载apk，在lib目录下有3个文件夹，不同的手机cpu型号对应不同的文件夹 。本人的手机加载的目标so文件在armeabi-v7a文件下： &emsp;&emsp;接着，ida加载libcocos2dlua.so文件，定位到函数luaL_loadbuffer，可以在函数中直接搜索，也可以字符串搜索 “[LUA ERROR]” 来定位到函数中，函数分析如下： 1LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,const char *name) &emsp;&emsp;所以在ARM汇编中，参数R0为lua_State指针，参数R1为脚本内容，R2为脚本大小，R3为脚本的名称，写一段IDC脚本dump数据即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;idc.idc&gt;static main()&#123; auto code, bp_addrese,fp,strPath,strFileName; bp_addrese = 0x7573022C; // luaL_loadbuffer函数地址 AddBpt(bp_addrese); // 下断点，也可以手动下断 while(1) &#123; code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, 15); // 等待断点发生，等待时间为15秒 if ( code &lt;= 0 ) &#123; Warning("错误代码：%d",code); return 0; &#125; Message ("地址：%a, 事件id：%x\n", GetEventEa(), GetEventId()); // 断点发生，打印消息 strFileName = GetString(GetRegValue("R3"),-1,0); // 获取文件路径名 strFileName = substr(strFileName,strrstr(strFileName,"/")+1,-1); // 获取最后一个‘/’后面的名字（文件的名字）去掉路径 strPath = sprintf("c:\\lua\\%s",strFileName); // 保存lua的本地路径 fp = fopen(strPath,"wb"); savefile(fp,0,GetRegValue("R1"),GetRegValue("R2")); fclose(fp); Message("保存文件成功: %s\n",strPath); &#125;&#125;//字符串查找函数，从后面向前查找，返回第一次查找的字符串下标static strrstr(str,substr1)&#123; auto i,index; index = -1; while (1) &#123; i = strstr(str,substr1); if (-1 == i) return index; str = substr(str,i+1,-1); index = index+i+1; &#125;;&#125; &emsp;&emsp;ida动态调试so文件网上有很多文章，这里就不详细说明了。通过idc脚本获取的部分数据如下： &emsp;&emsp;虽然文件的后缀名是.luac，但其实都是明文的lua脚本。 梦幻西游手游&emsp;&emsp;AndroidKiller反编译apk，查看lib下存在libcocos2dlua.so，基本上确定是lua写的： &emsp;&emsp;在assets\HashRes目录下，存在很多被加密的文件，这里存放的是lua脚本和游戏的其他资源文件： &emsp;&emsp;接着找lua脚本的解密过程，用ida加载libcocos2dlua.so文件，搜索luaL_loadbuffer函数，定位到关键位置，这里就是解密的过程了： &emsp;&emsp;分析解密lua文件过程如下： &emsp;&emsp;这里需要实现Lrc4解密的相关函数，还有Lzma解压函数需要自己实现，其他几个都是cocos2d平台自带的函数，直接调用就可以了。上面的流程图实现的函数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool decryptLua_Mhxy(string strFilePath, string strSaveDir)&#123; bool bResult = false; char *szBuffer = NULL; int nBufferSize = 0; CCFileUtils *utils = CCFileUtils::sharedFileUtils(); unsigned long ulFileSize = 0; char *szFileData = (char*)utils-&gt;getFileData(strFilePath.c_str(), "rb", &amp;ulFileSize); if (strncmp(szFileData, "L:grxx", 6)) &#123; if (!strncmp(szFileData, "__sign_of_g18_enc__", 0x13)) &#123; szBuffer = szFileData + 0x13; nBufferSize = ulFileSize - 0x13; bResult = decrypt((unsigned char*)szBuffer, nBufferSize); &#125; &#125; else if (!strncmp(szFileData + 6, "__sign_of_g18_enc__", 0x13)) &#123; unsigned char *pData = (unsigned char *)szFileData + 0x19; int nLen = ulFileSize - 0x19; bResult = decrypt(pData, nLen); if (ZipUtils::isGZipBuffer(pData, nLen)) &#123; nBufferSize = ZipUtils::ccInflateMemory(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else if (ZipUtils::isCCZBuffer(pData, nLen)) &#123; nBufferSize = ZipUtils::inflateCCZBuffer(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else if (LzmaUtils::isLzmaBuffer(pData, nLen)) &#123; nBufferSize = LzmaUtils::inflateLzmaBuffer(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else &#123; bResult = false; &#125; &#125; if(bResult) saveLuaData(szBuffer, nBufferSize, strSaveDir); return bResult;&#125; &emsp;&emsp;解密函数过程如下： &emsp;&emsp;decrypt()实现代码如下： 1234567bool decrypt(unsigned char *pData, int nLen)&#123; Lrc4 *pLrc4 = new Lrc4; Lrc4_lrc4(pLrc4); Lrc4_s(pLrc4, pData, nLen); return true;&#125; &emsp;&emsp;Lrc4结构如下: 12345678#define DATA_SIZE 256struct Lrc4&#123; unsigned char pData[DATA_SIZE]; //初始化时计算得到的256个字节 int nIndex; //记录下标 int nPreIndex; //记录前一个下标&#125;; &emsp;&emsp;其他函数的具体实现请看DecryptData_Mhxy.cpp文件，这里就不贴代码了。解密后的文件如下： &emsp;&emsp;可以看出，解密后的文件为luac字节码，但是这里直接用反编译工具是不能反编译luac字节码的，因为游戏的opcode被修改过了，我们需要找到游戏opcode的顺序，然后生成一个对应opcode的luadec.exe文件才能反编译。下表为修改前后的opcode： &emsp;&emsp;lua虚拟机的相关内容就不说明了，百度很多，这里说明下如何还原opcode的顺序。首先需要定位到opmode的地方，IDA搜索字符串”LOADK”，定位到opname的地方，交叉引用到代码，找到opmode： &emsp;&emsp;off_B02CEC为opname的地址，byte_A67C00为opmode的地址，进入opmode地址查看： &emsp;&emsp;这里没有把全部数据截图出来，可以看出，这里的opmode跟原opmode是不对应的。原opmode在lua源码中的lopcodes.c文件中： &emsp;&emsp;源码用了宏，计算出来的结果就是上表中opmode的结果。这里对比opmode就可以快速对比出opcode，因为opmode不相等，那么opcode也肯定不相等，到这一步，已经能还原部分opcode了，因为有一些opmode是唯一的。比如下面几个： &emsp;&emsp;如SETLIST，原opcode为34，opmode为0x14，找到的opmode的第8个字节也为0x14，则实际上SETLIST的opcode为8。 &emsp;&emsp;接下来就需要定位到luaV_execute函数，然后对比源码来还原其他的opcode，直接IDA搜索字符串”initial value must be a number”可以定位到luaV_execute 函数，再F5一下。接着打开lua源码中的lvm.c文件，找到luaV_execute函数，就可对比还原了。lua源码和IDA F5后的代码其实差别还是有的，而且源码用了大量的宏，所以源码只是用来参考、理解lua虚拟机的解析过程，本人在还原的过程中，会再打开一个没有修改opcode的libcocos2dlua.so文件，这样对比查找就方便多了。 &emsp;&emsp;最后修改lua源码 lopcodes.h中的opcode、lopcodes.c的opname和opmode，重新编译并生成luadec51 .exe（需要将lua源码中的src目录放到luadec51的lua目录下才能编译），就OK了，写个批处理文件就可以批量反编译。一个文件反编译的结果： 总结&emsp;&emsp;总结一下解密lua的流程，拿到APK，首先反编译，查看lib目录下是否有libcocos2dlua.so，存在的话很大可能这个游戏就是lua编写，其中lib目录下文件最大的就是目标so文件，一般情况就是libcocos2dlua.so。接着再看assert文件夹有没有可疑的文件，手游的资源文件会放到这个文件夹下，包括lua脚本。其次分析lua加密的方式并选择解密脚本的方式，如果可以ida动态调试，一般都会选择用idc脚本dump下lua代码。最后如果得到的不是lua明文，还需要再反编译一下。 &emsp;&emsp;不足之处：luajit的反编译并不完美，用的是luajit-decomp反编译工具，工具的作者也说只是满足了他自己的需求，还有一个luajit反编译是python写的工具ljd。其次梦幻luac的反编译部分代码反编译失败，修复过程请看这篇文章。 参考文章 腾讯游戏安全中心 《Lua游戏逆向及破解方法介绍》 http://gslab.qq.com/portal.php?mod=view&amp;aid=173 云风 《Lua源码欣赏》 https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/luadec/云风-lua源码欣赏-lua-5.2.pdf FSD-BlueEffie的博客 《梦幻西游手游 美术资源加密分析》 http://blog.csdn.net/blueeffie/article/details/50971665 Kaitiren的专栏 《Quick-cocos2d-x 与Cocos2dx 区别》 http://blog.csdn.net/kaitiren/article/details/35276177]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
</search>
