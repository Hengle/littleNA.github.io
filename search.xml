<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剖析2018腾讯游戏安全竞赛题目（上）]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%89%96%E6%9E%902018%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E9%A2%98%E7%9B%AE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录 目录 前言 STL逆向分析 Base64逆向分析 AES算法逆向分析 注册机实现 前言&emsp;&emsp;这篇文章的内容详细的分析2018腾讯游戏安全竞赛的赛题，一开始本来只是想跟大家分享一下我是如何逆向分析STL代码的，后面突发奇想要不把整个比赛的题目分析完写出文章，经过三个月的拖延症，终于搞完了资格赛的题目，后面应该还有一篇关于决赛题的分析，所以暂且将这篇命名为（上）。 STL逆向分析&emsp;&emsp;前年腾讯游戏安全资格赛有STL，去年也是，今天还是，足以看出腾讯对STL的基础是多么看重（敲黑板，同学们，划重点了！腾讯面试也经常考STL的知识！）。今天就从STL入手，详细的讲讲竞赛中用到的STL相关知识。 &emsp;&emsp;STL是Standard Template Library的简称，中文名标准模板库，从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。（这一段摘自百度百科） &emsp;&emsp;这里只讲如何学习string和vector逆向相关的内容，其他“容器”的分析方法都是一样的。当然不同编译器的STL实现可能不一样，我这边选择vs2010来说明（vs的不同版本实现应该差不太多）。 STL分析&emsp;&emsp;首先，弄明白一个类的结构对逆向是非常重要的，所以我们从结构入手去学习。接着，我们看看常用的类函数被编译器编译的结果是怎么样的（对比有无调试符号2种情况）。最后，提取关键特征，方便以后使用。Let’s go! &emsp;&emsp;通过查看string.h的代码，找出string的结构，提取结构如下： 1234567891011121314151617struct __cppobj std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; : std::_String_val&lt;char,std::allocator&lt;char&gt; &gt;&#123;&#125;;struct __cppobj __declspec(align(4)) std::_String_val&lt;char,std::allocator&lt;char&gt; &gt; : std::_Container_base0&#123; std::_String_val&lt;char,std::allocator&lt;char&gt; &gt;::_Bxty _Bx; unsigned int _Mysize; unsigned int _Myres;&#125;;union std::_String_val&lt;char,std::allocator&lt;char&gt; &gt;::_Bxty&#123; char _Buf[16]; char *_Ptr; char _Alias[16];&#125;; // 这是一个union结构，3个变量共用16字节内存。 &emsp;&emsp;通过上面的继承关系，总结一下string的结构大体如下： 1234567struct string&#123; char _Buf[16]; // 当字符串长度小于等于0xF时，数据存储在_Buf数组中 // 大于0xF时将分配一个变量，_Buf存储的是该变量地址。 unsigned int _Mysize; // 字符串长度 unsigned int _Myres; // 可存储的最大长度&#125; &emsp;&emsp;知道了string结构，就知道string的大小，16+4+4 = 24个字节，我们用OD调试验证一下： 字符串长度为4的string内存分布 字符串长度为0x17的string内存分布 &emsp;&emsp;接着，我们编译一个程序（源码在文末附件中），打开其源码和2个IDA进行对比分析（IDA一个加载调试符号PDB，一个不加载调试符号）。先看main函数的前2句代码： 源码 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;再来看看后面2句被ida反编译后的结果： &emsp;&emsp;我们也可以跟进testString（sub_401080）函数去看看，为了篇幅原因，这里就不再细说了，大家有需要可以自己去对比分析一下。最后我们总结一下，根据ida的分析，我们知道string的初始化情况，大约有2种： 123456789101112131415// 第一种，v18是一个stringint v18; // [sp+2Ch] [bp-30h]@1int v19; // [sp+3Ch] [bp-20h]@1unsigned int v20; // [sp+40h] [bp-1Ch]@1v20 = 0xF;v19 = 0;LOBYTE(v18) = 0;// --------------------------------------// 第二种，a1是一个string*(_DWORD *)(a1 + 0x14) = 0xF;*(_DWORD *)(a1 + 0x10) = 0;*(_BYTE *)a1 = 0; &emsp;&emsp;这就是string的初始化结构，其实这两种本质上是一样的，一个局部变量，一个是参数变量。当遇到这两种结构，那么很大可能就是一个sting变量。还有一点需要提一下，就是string有2种存储结构，所以每次取string里的字符串时，都需要判断一下最大长度 _Myres 是否大于0x10，这个也是很经典的一个特征，如下： 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;其他string相关的函数大家可以直接去跟一下，反正就那么几个，这里直接给出一些总结： 函数名 参数 特征 解析 string.erase this,off,count ● 存在字符串”invalid string position”● 调用_memmove()函数 - string._copy string,newsize,oldsize - - string.append a1,a2 ● 存在2个字符串”string too long”● 调用了_copy()函数 ● 如果_copy中的newsize = oldsize+1,则append相当于string+=char;● 如果_copy中的newsize = oldsize+size,则append相当于string+=string; string.asign str1,off,count,str2 ● 存在2个字符串”invalid string position”● 存在字符串”string too long● 调用2次erase(),1次_copy(),1次_memcpy() ● 用str2初始化str1● 相当于str1=str2; string._Grow str1,size,bool ● 存在字符串”string too long”● 调用1次_copy(),1次_memcpy() sting.operator+ str1,str2,str3 ● 调用1次_Grow()● 最后2次连续的append()和return ● append(str1,str2);● append(str1,str3);● return str1;● 相对于str1=str2+str3; string.substr off,count ● 初始化string并且调用asign() ● asign()函数有2个参数就是需要截断的位置和长度 &emsp;&emsp;接着看看vector容器，方法还是一样，先来看看代码里面的结构，提取如下： 1234567891011struct __cppobj std::vector&lt;char,std::allocator&lt;char&gt; &gt; : std::_Vector_val&lt;char,std::allocator&lt;char&gt; &gt;&#123;&#125;;struct __cppobj __declspec(align(4)) std::_Vector_val&lt;char,std::allocator&lt;char&gt; &gt; : std::_Container_base0&#123; char *_Myfirst; char *_Mylast; char *_Myend; std::allocator&lt;char&gt; _Alval;&#125;; &emsp;&emsp;这个就是vector的结构了，简化一下： 123456struct vector&#123; char *_Myfirst; // 指向第一个元素 char *_Mylast; // 指向最后一个元素 char *_Myend; // 指向预分配内存的最后一个位置&#125;; &emsp;&emsp;vector是一个数组，数组的元素 T 都是连续存储在一块内存空间中，其中_Myfirst 指针指向第一个元素，_Mylast 指向最后一个元素，那么很容易想到，数组元素的个数就等于 (_Mylast -_Myfirst) / sizeof(T) 。 &emsp;&emsp;接下来以vector、vector、vector、vector为例说明，先看2个例子： &emsp;&emsp;结构上跟源码基本无差，只是back()和pop_back()函数被优化了，再来看看vector类型，这次用了另一种方式初始化： 源码 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;这种初始化方式会使用到vector类型的一个函数_Construct()，内部调用了insert将连续的数组插入到vector中。testVec的源码如下： 123456789101112131415vector&lt;int&gt; testVec(vector&lt;int&gt; &amp;vecInt)&#123; vector&lt;int&gt; vecRet; for (vector&lt;int&gt;::iterator it=vecInt.begin();it!=vecInt.end();it++) &#123; vecRet.push_back((*it)*999); &#125; for (int i=0;i&lt;vecInt.size();i++) &#123; vecRet.push_back(vecInt.back()); vecInt.pop_back(); &#125; return vecRet;&#125; &emsp;&emsp;如果IDA跟进到testVec函数里，会发现跟源代码差距非常大，原因是testVec函数里面的所有跟vector相关的函数(如begin()、push_back()、back() 等)都被优化了（库函数代码跟用户代码优化在一起了），不过细心去分析，会发现大部分代码都是在判断vector的空间是否需要重新分配，如果需要则调用reserve()函数进行调整。 &emsp;&emsp;看一个动态调整大小的例子，并且看看动态调整大小的方法： &emsp;&emsp;从上面的分析可以看出，动态调整的规则是以每次增加一半来调整的，如果增加一半的大小会溢出，则每次只调整加1，这也是为何当存储量很大的时候，STL会非常慢。 &emsp;&emsp;最后是vector、vector这两种，本质上struct和class是一样的。分析表明，这两种类型被编译后基本上也是跟vector类似的，这里只说明一下，如何确定元素struct或者class的大小。有2种方法，1)是通过循环时查看对_Myfirst增加的大小，这个大小就是元素结构的大小，例如： 12345678v3 = vecFlag-&gt;_Myfirst;for ( i = (int)v3; v3 != vecFlag-&gt;_Mylast; i = (int)v3 )&#123;... v21 = i； v3 = v21 + 8;&#125;// 则8就是元素的大小 &emsp;&emsp;2)是找到_Uninit_copy()函数，里面包含了对整个结构的初始化，对逆向非常有帮助，例如AClass： 源码 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;从上图我们知道，这是一个类，类中有1个虚表，虚表里面有1个虚函数，类一共包括3个成员变量，类的大小一共 16 字节。 &emsp;&emsp;vector差不多就分析到这里，最后给出总结： 函数名 参数 特征 解析 vector.push_back a1 ● 存在2个字符串”vector too long” ● 特殊，会存在函数，不会被优化 vector.reserve vector1,size ● 存在字符串”vector too long”● 调用 new,allocate,memmove,delete 等函数 ● 如果size大于vector1的预分配内存空间的话，重新分配大小size vector.insert - ● 存在字符串”vector too long” ● 插入一个元素 vector._Construct - ● IDA F5后只有3行代码● 调用insert()函数 - vector.push_backvector.pop_backvector.back - ● 被优化在调用函数里面，没有独立的函数● 调用函数会判断vector大小并动态改变● 调用函数里面也会出现”vector too long”字符串 ● push_back(v1) –&gt; 取元素v1，判断vector的last是否等于end，是的话增加大小将v1赋值给last，last+=1(这里是指指向下一个元素，这里1要看vector里面元素的大小，如果是int，这里是4，如果是类，这里就是类的大小)● back() –&gt; 取last-1(就是指最后一个元素)● pop_back() –&gt; last-=1 算法逆向分析&emsp;&emsp;在开始分析题目前，我们回顾下上一节的内容，先来看看vector的结构是怎么样的，例子如下： 12string str[]=&#123;"1234","12345","123456","12345678901234567890"&#125;; vector&lt;string&gt; strArray(str, str+4); &emsp;&emsp;内存结构分析，如下： &emsp;&emsp;根据上一节的分析，string的大小是24字节，vector存储了4个string结构，系统预分配了2个结构。 &emsp;&emsp;开始分析程序，首先运行发现是mfc程序，使用xspy工具获取按钮事件的处理函数是sub_4026F0， 12xspy工具原贴：https://bbs.pediy.com/thread-170033.htm （感谢作者lynnux）xspy开源地址：https://github.com/lynnux/xspy 接着IDA分析： &emsp;&emsp;这里62-64行就是string初始化的经典结构，v14就是string类型，然后通过上下文可以知道，sub_402A70就是string.assign函数，赋值RegCode(v23)给v14。同样分析，v8也是string类型，保存了UserName。通过第80行的判断条件知道，sub_405510 函数返回1则显示成功，返回0则失败。接着我们来分析sub_405510 函数（这里我们需要记住传进去的参数），首先看看整体结构（只提取一些关键函数）： 1234567891011121314151617if ( sub_404F00() ) // 1&#123; sub_405040(); // 2 if ( sub_406080() &amp;&amp; ( a13 || sub_403010() )） // 3 &#123; v13 = sub_402F20(); // 4 &#125; else &#123; v13 = 0; &#125;&#125;else&#123; v13 = 0;&#125;return v13; &emsp;&emsp;v13是该函数的返回结果，必须返回1才能通过验证，也就是说第一个if判断中的sub_404F00()函数得返回真，之后执行sub_405040()函数。下一个if判断条件也得为真，即sub_406080()为真并且( a13 || sub_403010() )为真，这里a13是外部传进来标记是普通版还是进阶版的变量，当其为0时，sub_403010()函数得为真。最后执行sub_402F20()函数将结果赋值给v13。先看sub_404F00函数： &emsp;&emsp;一开始判断了字符串的长度是否等于39，接着31-35行的典型的取string类型中字符串(char*)的标准结构，同理36-39行、41-44行也是，后面还会出现这样的结构，就不再重复了。 &emsp;&emsp;这个循环是将所有的字符传递给sub_552E03函数，而该判断字符为小写字母时，将其转换为大写字母，函数内部主要的三行代码如下： &emsp;&emsp;接着往下看： &emsp;&emsp;这里出现了一个关键函数sub_404D70，然后进去分析，发现是split函数（本身STL是不包含这个函数），并且推断出v24是vector结构，数组元素个数是8。sub_404D70函数的分析如下： &emsp;&emsp;回到上一个函数继续分析最后一段： &emsp;&emsp;总结一下sub_404F00函数：函数的参数是UserName（string类型），函数判断了UserName的长度是否39，将存在的小写字母转化成大写字母，并通过调用split函数将其按照 “#” 符号进行分割，保存在vector结构中，分析得出是8个元素的数组，最后的判断限制了这些字符只能是 “0123456789ABCDEF” 这16个字符。通过以上分析，猜测UserName的格式是 “xxxx#xxxx#xxxx#xxxx#xxxx#xxxx#xxxx#xxxx”，x的范围为 “0123456789ABCDEFabcdef” 。 &emsp;&emsp;接着分析第2个函数，sub_405040函数，这个函数参数是上面转换成大写字母后的UserName，计算结果返回5个int64的值。这个函数很长很长，但是基本结构都是差不多的，这里只分析一小段： &emsp;&emsp;这里要说一下出现的偏移24、48，包括后面出现的72、96等，都是取vector数组元素的值，比如24*2=48，那么 v111[0]+48 就是取 vector[2] 的值。然后这里的主要计算是在135行和146行，细心提取就OK了。 编码实现&emsp;&emsp;最后使用c++将上节分析的2个函数的功能实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283vector&lt;string&gt; split(string str, string pattern)&#123; int pos; vector&lt;string&gt; result; str += pattern; int size = str.size(); for (int i = 0; i&lt;size; i++) &#123; pos = str.find(pattern, i); if (pos&lt;size) &#123; std::string s = str.substr(i, pos - i); result.push_back(s); i = pos + pattern.size() - 1; &#125; &#125; return result;&#125;bool CheckAndCalcUserName(string strUserName, _int64 &amp;nTmp1, _int64 &amp;nTmp2, _int64 &amp;nTmp3, _int64 &amp;nTmp4, _int64 &amp;nTmp5)&#123; // 将小写字母转化成大写字母 for(int i = 0;i&lt;strUserName.length();i++) if((unsigned int)(strUserName[i]-97)&lt;=0x19) strUserName[i] = strUserName[i] - 0x20; // 分割字符串，并判断元素个数 vector&lt;string&gt; vec_name = split(strUserName, "#"); if (vec_name.size() != 8) &#123; return false; &#125; // 判断所有字符是否在 "013456789ABCDEF" 这16个字符中 for(int i = 0;i&lt;vec_name.size();i++) &#123; string strTmp = vec_name[i]; for(int j=0;j&lt;strTmp.length();j++) &#123; char chTmp = strTmp[j]; if( (chTmp &gt; 57 || chTmp &lt; 48) &amp;&amp; (unsigned char)(chTmp - 65) &gt; 5 ) return false; &#125; &#125; // 开始计算 nTmp1 = (vec_name[0][0] * vec_name[1][0]) &lt;&lt; 16; nTmp1 += vec_name[0][1] ^ vec_name[2][1]; nTmp1 += (vec_name[0][2] % (vec_name[3][2] + 1)) + 1; nTmp1 += int(vec_name[0][2] / (vec_name[4][3] + 1)); nTmp2 = (vec_name[1][0] ^ vec_name[5][0]) &lt;&lt; 16; nTmp2 += vec_name[1][1] % (vec_name[6][1] + 3); nTmp2 += int(vec_name[1][2] / (vec_name[7][2] + 1)) + 5; nTmp2 += vec_name[1][3] + vec_name[0][3]; nTmp3 = int(vec_name[2][0] / (vec_name[1][0] + 3)) &lt;&lt; 16; nTmp3 ^= vec_name[2][1] % vec_name[3][1]; nTmp3 += vec_name[2][2] + vec_name[5][2] + 12; nTmp3 += vec_name[2][3] + vec_name[7][3]; nTmp4 = vec_name[0][1] ^ vec_name[2][3]; nTmp4 *= vec_name[1][3] + vec_name[3][1]; nTmp4 &amp;= vec_name[4][2] &amp; vec_name[5][2]; nTmp4 *= vec_name[7][3]; nTmp4 += nTmp2; nTmp4 *= vec_name[6][0]; nTmp4 *= nTmp1; _int64 t2 = nTmp4; t2 -= nTmp2; _int64 t = nTmp1 * 2; t = t2%t; nTmp4 -= t; nTmp5 = (vec_name[3][0] ^ vec_name[4][0]) &lt;&lt; 16; nTmp5 = nTmp5 * (vec_name[3][1] % (vec_name[4][1] + 2)); nTmp5 += (vec_name[3][2] % (vec_name[4][2] + 5)) + 7; nTmp5 += vec_name[3][3] * vec_name[4][3]; return true;&#125; Base64逆向分析&emsp;&emsp;Base64算法大家都用过，这个算法出现的主要的原因是解决有一些网络传输只支持可见字符的传输，而并不支持所有的字节的问题，base64算法能够将所有字节转换成可见字符。 Base64的编码与解码&emsp;&emsp;Base64的编码表如下：”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/“，一共64个字符，所以只需要6位就能表示，从0-63分别对应一个字符。一般比赛中Base64算法都会修改这个编码表（有些还会修改算法），从而导致正常base64算法无法解码，加强难度。也有作者通过爆破的方式解码base64中的编码表，当然，修改了算法的话，就无法爆破了。 &emsp;&emsp;一个字节是8位，base64每6位编码一次，也就是说，3个字节被base64编码后刚好等于4个字符，这对于优化计算也是非常重要的。如果不够3个字节将进行补0操作，补0中的6个0用“=”表示，这也是为什么base64编码后的字符串往往会有那么1，2个等号结尾。解码就是讲上述步骤反过来，下面看一个例子： &emsp;&emsp;上面是使用base64对字符串“1034”的编码和解码过程，编码后的结果为“MTAzNA==”。前面说了，编码时后补的6个0编码为“=”字符，不是后补的0是下标0，编码为“A”字符，如上面的红框。主要的代码实现如下： 12345678910// 编码核心代码index[0] = str[0] &gt;&gt; 2;index[1] = ((str[0] &amp; 0x3) &lt;&lt; 4) + (str[1] &gt;&gt; 4);index[2] = ((str[1] &amp; 0xF) &lt;&lt; 4) + (str[2] &gt;&gt; 6);index[3] = str[2] &amp; 0x3F;// 解码核心代码str[0] = (index[0] &lt;&lt; 2) + (index[1] &gt;&gt; 4);str[1] = (index[1] &lt;&lt; 4) + (index[2] &gt;&gt; 2);str[2] = (index[2] &lt;&lt; 6) + index[3]; &emsp;&emsp;base64的算法就介绍到这里，接下来说说这次比赛中使用到的base64算法。 Base64逆向分析&emsp;&emsp;我们进入sub_406080进行分析，F5一下。首先看下函数头： 1char __fastcall sub_406080(const char *a1, int a2) &emsp;&emsp;从该函数的外部我们知道，a1为我们输入的key字符串，那第二个参数是什么呢？不难发现，利用上一节STL的内容，通过跟踪变量，我们发现它很有可能是一个vector类型的变量，其中T可能是char类型，这个vector变量保存了该函数的计算结果。 &emsp;&emsp;知道了参数的意义，我们从反编译的第一行开始看起，首先有4个xmmword_xxxxxx类型的赋值语句给变量v26-v29赋值，从ida对变量的注释开始，我们知道变量v26-v29是在栈的连续空间中，__int128是16个字节，4个变量共16*4 = 64个字节，双击查看任何一个xmmword_xxxxxx变量，可以发现如下的值( 这里xmmword_5AC470没有使用 )： &emsp;&emsp;也就是说，这64个字节都是可视字符，他们排序的结果如下“ZO6Kq79L&amp;CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#”。为什么这里要分4个值赋值呢？其实是为了防止一眼看出这个是在初始化编码表。从这里我们大约已经可以猜测，这可能是一个base64的算法，并且编码表被修改了。我们接着分析： &emsp;&emsp;这里46行判断了key的长度是否是4的倍数，如果不是则返回false，前面分析已经知道了，base64编码后的字符串必须是4的倍数。接着跳转到第120的else块，分析如下： &emsp;&emsp;通过逐步分析，我们知道这个else块主要是获取key中的每一个字符并判断是否在base64的编码表中，如果存在某一个字符不在编码表中则返回flase，如果所有字符都没有问题，则跳转到LABEL_13中继续执行。细心的朋友可能会发现，如果key最后存在字符“=”不就不满足上面的循环了吗？因为“=”不在编码表中啊。确实，我也纠结了一小会，但是我们仔细看看v26初始化的那一段，会发现存在一个v30的变量，这个变量在41行被赋值为0x3d，而0x3d恰好是字符“=”的ascii码。也就是时候，在栈空间中，编码表的最后一个字符是“=”，其长度变成65。（这里OD动态调试一下就明白了） &emsp;&emsp;ida中，鼠标点一下41行的0x3d，并按键盘的R健，可以将0x3d按字符格式显示为“=”: &emsp;&emsp;继续分析 LABEL_13开始的代码。我们发现，从LABEL_13开始跟着1个大循环，大循环里面跟着4个小循环，首先我们分析小循环的代码，分析知道，每一个小循环是计算key中某一个字符在编码表中的位置，然后再通过66行的转换得到一个值，注意了，在正常的base64算法中，这个值是下标值，但是这里的算法被修改过，得到的是 index^(index &gt;&gt;3)。其他3个小循环的结构基本一样，唯一要注意的是63行v10相关的值，其实4个小循环分别计算key中4个字符对应的值。 &emsp;&emsp;计算的4个值分别保存到v13、v15、v18、v24中，记住，虽然这4个变量是byte型（8位），但是他们的值都小于64（6位） &emsp;&emsp;我们前面分析到sub_405EB0函数是与vector相关的函数，结合上下文和参数（也可以结合OD，看vector数据的变化和数组大小的变换），我们可以确定该函数是puth_back函数（保存计算的v25值到v22中），并且v22属于vector类型。 &emsp;&emsp;接着我们再来看看v25的值是如何计算的，其实已经很明显了，就是base64的解码运算，通过对v13、v15、v18、v24的移位和组合，得到个3 v25的值（4字节变3字节）。 注： 上图IDA中备注的高、低位只取字节的后6位（小于64） &emsp;&emsp;最后，我们总结一下这个base64的解码函数： 编码表被修改过。 取字符在编码表的位置后，多计算了一步（ index^(index &gt;&gt;3) ）。 解码的算法没有变。 &emsp;&emsp;解码流程写出来了，那么相应的编码函数也很简单，就是逆向解码流程，注意流程的第2点，它的逆向操作也是一样的计算，比如：result = index^(index&gt;&gt;3)，那么 result^(result&gt;&gt;3) 也就等于index。 编码与解码&emsp;&emsp;用c++实现base64的编码和解密函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273string strTbl = "ZO6Kq79L&amp;CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#";string Base64_Encode(string str)&#123; unsigned char index[4]; string strRet = ""; int i = 0; for (i = 0; i&lt;str.length() / 3; i += 1) &#123; index[0] = (unsigned char)str[i * 3 + 0] &gt;&gt; 2; index[1] = ((unsigned char)(str[i * 3 + 0] &amp; 0x3) &lt;&lt; 4) + ((unsigned char)str[i * 3 + 1] &gt;&gt; 4); index[2] = ((unsigned char)(str[i * 3 + 1] &amp; 0xF) &lt;&lt; 2) + ((unsigned char)str[i * 3 + 2] &gt;&gt; 6); index[3] = (unsigned char)str[i * 3 + 2] &amp; 0x3F; for (int j = 0; j&lt;4; j += 1) strRet += strTbl[index[j] ^ (index[j] &gt;&gt; 3)]; &#125; int n = str.length() % 3; if (n &gt;0) &#123; str += '\x00'; index[0] = (unsigned char)str[i * 3 + 0] &gt;&gt; 2; index[1] = ((unsigned char)(str[i * 3 + 0] &amp; 0x3) &lt;&lt; 4) + ((unsigned char)str[i * 3 + 1] &gt;&gt; 4); strRet += strTbl[index[0] ^ (index[0] &gt;&gt; 3)]; strRet += strTbl[index[1] ^ (index[1] &gt;&gt; 3)]; if (n == 1) &#123; strRet += "=="; &#125; else if (n == 2) &#123; str += '\x00'; index[2] = ((unsigned char)(str[i * 3 + 1] &amp; 0xF) &lt;&lt; 2) + ((unsigned char)str[i * 3 + 2] &gt;&gt; 6); strRet += strTbl[index[2] ^ (index[2] &gt;&gt; 3)]; strRet += "="; &#125; &#125; return strRet;&#125;string Base64_Decode(string str)&#123; unsigned char index[4]; string strRet = ""; for (int a = 0; a&lt;str.length() / 4; a++) &#123; for (int i = 0; i&lt;4; i++) &#123; for (int j = 0; j&lt;strTbl.length(); j++) &#123; if (str[a * 4 + i] == strTbl[j]) &#123; index[i] = j ^ (j &gt;&gt; 3); &#125; &#125; &#125; strRet += (index[0] &lt;&lt; 2) + (index[1] &gt;&gt; 4); if (str[a * 4 + 2] == '=') break; strRet += (index[1] &lt;&lt; 4) + (index[2] &gt;&gt; 2); if (str[a * 4 + 3] == '=') break; strRet += (index[2] &lt;&lt; 6) + index[3]; &#125; return strRet;&#125; AES算法逆向AES加解密分析&emsp;&emsp;这一节的主要内容可以参考《深入浅出密码学：常用加密技术原理与应用》第4章内容，详细知识书上都有说，这里只是简单说一说整个加解密的流程： 图片来源：《深入浅出密码学：常用加密技术原理与应用》 &emsp;&emsp;从上图可以看出，AES加密涉及到4个层（解密就是逆向运算）： 密钥拓展层（变换）。注：AES有一个特征，字节代换层存在SBox（加密使用）和iSBox（解密使用）。 密钥加法层。 字节代换层。 扩展层：ShiftRows层 和 MixColumn层。 &emsp;&emsp;分组加密方式的工作模式也可以分为好几种，wiki上面分为6种，如下： &emsp;&emsp;ECB模式指每一组明文加密都是独立的，而其他模式的加密会依赖于前后块的密文。ECB模式也是属于最弱的模型，重放攻击就是其受到的攻击之一。因此ECB模型下，相同的明文块加密后的密文也是相同的。这次比赛使用的就是ECB模型，确认方法也很简单，我们输入相同的块看AES加密后的密文是否相同就能确认。 &emsp;&emsp;加密前的字节： &emsp;&emsp;加密后的字节： &emsp;&emsp;我们可以发现，在相同明文块下（2行刚好就是2块），加密的结果是一样的，那么就是ECB模式了。 AES逆向分析&emsp;&emsp;掌握以上知识，我们开始逆向分析这次的变种AES算法，这个变种函数很多流程都被修改，但是还是有一些AES的细节被保留（比如 SBox、RC数组、MixColumn矩阵等），当我们分析透彻的话，写出逆向算法还是不难的。 &emsp;&emsp;首先，先分sub_403010函数的参数，根据传入的参数，我们知道改函数的结构如下： 123456// 参数 a1 为a2的长度size// 参数 a2 为vector&lt;char&gt;类型// 参数 a3 为传入的字符串（后面分析知道是AES加密的key）// 参数 a4 未使用// 参数 a5 为 a2char __usercall sub_403010@&lt;al&gt;(signed int a1_size@&lt;edx&gt;, vertor&lt;char&gt; a2, char* a3_key, int a4_unknow, vertor&lt;char&gt; a5) &emsp;&emsp;接着开始分析第一段，密钥拓展层： &emsp;&emsp;第269行的dword_5ABB88变量，我们点击进去看一下: &emsp;&emsp;这里其实是密钥拓展层用到的一个变量轮系数RC，但是轮系数RC的值本应该是这样的： 1char *szRC = &#123;1,2,4,8,0x10,0x20,0x40,0x80,0x1B,0x36&#125;; &emsp;&emsp;也就是说，这里的轮系数是32位数组，其中每个元素的高8位保存着数值（方面AES的g()函数进行32位异或） ，但是该题用错了，拿32位跟一个byte相与，导致后面的299行的 v15&amp;*v232 运算常为0，我们后面分析。 &emsp;&emsp;270行至281行的内容是把密钥从16字节的byte型数组转换成4个4字节的int型数组，这个非常容易看出来。接着284行至307行是一个的循环，这个是密钥拓展层的主要逻辑，通过分析发现，该密钥拓展算法跟正常的密钥拓展算法只是g()函数的实现有差异，如下图： 原AES的密钥拓展流程 修改后的密钥拓展流程g()函数 图片来源：《深入浅出密码学：常用加密技术原理与应用》 &emsp;&emsp;从上图可以看出g()函数的不同之处，首先位移的位置不同，其次经过SBox转换后，修改版还多了跟原值异或这一步，最后再进行RC相关的操作。这里RC[i]是32位，并且高8位才有数值，其它位为0，与上一个8位的数值，结果常为0，任何数与0异或都是它本身，所以相当于没有与RC操作这一步了。 &emsp;&emsp;以上就是密钥拓展层，在解题的时候这一部分是不用分析的，直接从内存里抠出来利用就行，但是平时学习的话还是有必要分析一下。 &emsp;&emsp;生成完密钥后，接着是对待解密的数组进行一系列的操作。首先是对待解密的字节数组进行转换，单字节转换成DWORD并且进行转置操作（下图的314行至330行），然后与密钥组进行异或（332行至343行）： &emsp;&emsp;上图变量v257所指向的空间就是计算过程中保存的结果，后面很多层都可以通过动态调试对结果的分析看出来，而不用实际去分析代码。接着进行逆向的SBox变换（iSBox）： &emsp;&emsp;接着是逆向的shift_row层（步骤8），这里进行静态分析比较麻烦，直接动态跟踪输入输出的变化就能看出来： &emsp;&emsp;shift_row层过后是MixColumn层（步骤9），因为是解密函数，所以是逆向的MixColumn层： &emsp;&emsp;这层的识别非常容易，查看dword_5ABBB0变量，发现其实就是InvMixColumn层的一个矩阵： dword_5ABBB0变量空间 逆向的MixColumn层 MixColumn层 &emsp;&emsp;而这里的矩阵乘法非常不同，不是用的乘法实现，而是对每一个字节进行判断再进行对应的操作，用了一大串switch结构，这样的实现导致代码量比较大，不过多看几遍就懂了。 &emsp;&emsp;（后面的层跟前面的层代码结构类似，只要注意下输入输出就好，这里不再列举代码，有兴趣的同学可以分析分析idb ）接着再取倒数第二行的key，对key进行InvMixColumn层变换，再一次进行密钥加法层的运行。然后以上步骤从iSBox层开始循环9次。经过9次循环后，最后对结果再进行一次iSBox变换和ShiftRow层变换，并取第一行的key与结果相异或，得到的就是最终结果。 AES加密与解密&emsp;&emsp;上一节我们分析了解密函数，这一节我们需要还原加密函数，在这之前，我们再把解密流程梳理一下，整理成流程图： &emsp;&emsp;对比《深入浅出密码学：常用加密技术原理与应用》中AES算法的加密与解密流程图，我们发现这个解密函数左边的流程图跟AES的加密函数一样，而右边的密钥拓展流程图又跟解密函数的密钥流程图一样，这真是魔改版的AES啊。最后实现加密函数，我们只需要按照该解密函数反向操作就行了，这里不再说明，有兴趣的同学可以看附加中的代码，代码实现了该魔改版AES的加密和解密函数，编码过程还有一个需要注意的是，这里的SBox和iSbox都是经过变换的，跟原版的AES的Box不一样，需要从文件中dump出来。 注册机的实现&emsp;&emsp;前面的3节分析了整个题目的90%，我们还有最后一个函数sub_402F20，现在再来看看整个分析： &emsp;&emsp;进去看看sub_402F20长啥样子： &emsp;&emsp;上面的函数参数经过了重命名，参数是8个int64类型的值（T1-T5已知，求T6,T7,T8），按照参数压栈的方式顺序命名就好了。最后将代码整理成求解的方程，如下： 123_int64 nTmp6 = (nTmp4 - nTmp2) / (2 * nTmp1); _int64 nTmp7 = nTmp6*nTmp6*nTmp1 + nTmp6*nTmp2 + nTmp3; _int64 nTmp8 = nTmp3 + ((nTmp2 + (nTmp1*nTmp5) - nTmp4) * nTmp5); &emsp;&emsp;目前我们逆向完了整个校验的过程，接着考虑如何写注册机。在这之前，把整个校验过程总结如下： &emsp;&emsp;明白了整个校验过程，那么写注册机就比较简单，UserName 流程不变，RegCode通过倒推回去就能计算出来。首先，通过UserName计算出T1-T5，然后通过解方程计算出T6-T8，接着拼接T9（T9为字符串”2018\x00\x00\x00\x00”）输入到AES加密算法中，得到数据最后再进行一次Base64编码，最终的结果就是我们需要的RegCode。详情请看附件中的代码。 附件下载 (上篇完)]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>游戏安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018看雪·京东AI CTF大挑战特别题 writeup]]></title>
    <url>%2F2018%2F07%2F16%2F2018%E7%9C%8B%E9%9B%AA%C2%B7%E4%BA%AC%E4%B8%9CAI-CTF%E5%A4%A7%E6%8C%91%E6%88%98%E7%89%B9%E5%88%AB%E9%A2%98-writeup%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;非常荣幸，这次AI与CTF结合的比赛本人获得了第二名（估计很多大佬懒得做，都跑去打常规赛了）。这一篇文章是本人发在看雪的解题报告，现转载到个人博客。原地址 请点击这里 前言&emsp;&emsp;前不久自己也思考过能不能将热门的AI技术与CTF比赛结合起来，没想到就意外发现了这道题，感觉非常有趣。 题目解析&emsp;&emsp;首先，阅读题目，发现模型是使用深度学习来检测一段二进制代码中是否存在函数入口，存在的话将入口点标为1，否则为0。而题目需要我们对模型机进行微调，使得模型能够识别出一段不能识别的二进制代码的入口点。说白就是我们需要造一些样本，重新训练模型使得模型能够识别给定样本的函数入口点并保证不是入口点也能识别正确。题目提供了模型的文件和样本点2个数据。 &emsp;&emsp;接着，我们需要看看模型是使用什么框架生成的，查看模型文件的二进制代码，发现是hdf文件： &emsp;&emsp;使用python的h5py工具解析，发现模型是基于theano工具的keras框架生成的，使用的RNN算法： &emsp;&emsp;代码如下： 123456789101112131415161718192021222324252627282930313233import h5pydef print_dateset(name,d): if type(d).__name__ == "Group": print(" &#123;&#125;".format(name)) for name1, d1 in d.items(): print_dateset(name1,d1) else: print(" &#123;&#125;: &#123;&#125;".format(name, d.value.shape)) # 输出储存在Dataset中的层名称和权重 print(" &#123;&#125;: &#123;&#125;".format(name, d.value))def print_keras_wegiths(weight_file_path): f = h5py.File(weight_file_path) # 读取weights h5文件返回File类 try: if len(f.attrs.items()): print("&#123;&#125; contains: ".format(weight_file_path)) print("Root attributes:") for key, value in f.attrs.items(): print(" &#123;&#125;: &#123;&#125;".format(key, value)) # 输出储存在File类中的attrs信息，一般是各层的名称 for layer, g in f.items(): # 读取各层的名称以及包含层信息的Group类 print(" &#123;&#125;".format(layer)) print(" Attributes:") for key, value in g.attrs.items(): # 输出储存在Group类中的attrs信息，一般是各层的weights和bias及他们的名称 print(" &#123;&#125;: &#123;&#125;".format(key, value)) print(" Dataset:") for name, d in g.items(): # 读取各层储存具体信息的Dataset类 print_dateset(name,d) finally: f.close()print_keras_wegiths("gcc_O2.h5") &emsp;&emsp;之后使用keras自带的模型绘制接口，将模型结构图打印出来： &emsp;&emsp;代码如下： 12345from keras.models import load_modelfrom keras.utils import plot_modelmodel = load_model("gcc_O2.h5")plot_model(model, to_file='model.png',show_shapes=True) &emsp;&emsp;知道了模型使用的框架，那么之后重新训练模型就非常方便了，再来看看样本点。观察发现，一段正常二进制代码应该会存在很多个0，而样本点存在很多个1且没有0，同时单字节存在几个256（单字节最大应该只有255），所以这里的二进制代码是经过加1运算后的代码，我们通过减1再进行反汇编，看看函数的入口特征： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859600048E000 &gt; 31C0 xor eax,eax 0048E002 83FA 0F cmp edx,0xF0048E005 0f94c0 sete al0048E008 &gt; 8D04C5 08000000 lea eax,dword ptr ds:[eax*8+0x8]0048E00F C3 retn0048E010 &gt; 31C0 xor eax,eax 0048E012 83FA 0F cmp edx,0xF0048E015 0f94c0 sete al0048E018 &gt; 8D04C5 09000000 lea eax,dword ptr ds:[eax*8+0x9]0048E01F C3 retn0048E020 &gt; 90 nop0048E021 8DB426 00000000 lea esi,dword ptr ds:[esi]0048E028 &gt; 83EC 0C sub esp,0xC0048E02B 895C24 04 mov dword ptr ss:[esp+0x4],ebx0048E02F 31DB xor ebx,ebx0048E031 897424 08 mov dword ptr ss:[esp+0x8],esi0048E035 89C6 mov esi,eax 0048E037 0FB6041E movzx eax,byte ptr ds:[esi+ebx]0048E03B E8 18FFFFFF call 0048DF580048E040 &gt; 83F8 14 cmp eax,0x140048E043 76 0B jbe 0048E0500048E045 E8 7E3AFFFF call 00481AC80048E04A 8DB6 00000000 lea esi,dword ptr ds:[esi]0048E050 &gt; FF2485 A8910F08 jmp dword ptr ds:[eax*4+0x80F91A8]0048E057 90 nop0048E058 &gt; B8 03000000 mov eax,0x30048E05D 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E061 01D8 add eax,ebx0048E063 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E067 83C4 0C add esp,0xC0048E06A C3 retn0048E06B 90 nop0048E06C &gt; 8D7426 00 lea esi,dword ptr ds:[esi]0048E070 &gt; B8 02000000 mov eax,0x20048E075 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E079 01D8 add eax,ebx0048E07B 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E07F 83C4 0C add esp,0xC0048E082 C3 retn0048E083 90 nop0048E084 &gt; 8D7426 00 lea esi,dword ptr ds:[esi]0048E088 &gt; 83C3 01 add ebx,0x10048E08B ^ EB AA jmp short idaq.0048E0370048E08D 8D76 00 lea esi,dword ptr ds:[esi]0048E090 &gt; B8 01000000 mov eax,0x10048E095 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E099 01D8 add eax,ebx0048E09B 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E09F 83C4 0C add esp,0xC0048E0A2 C3 retn0048E0A3 90 nop0048E0A4 &gt; 8D7426 00 lea esi,dword ptr ds:[esi]0048E0A8 &gt; B8 05000000 mov eax,0x50048E0AD 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E0B1 01D8 add eax,ebx0048E0B3 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E0B7 83C4 0C add esp,0xC0048E0BA C3 retn0048E0BB 8DB6 00000000 lea esi,dword ptr ds:[esi]0048E0C1 8DBC27 00000000 lea edi,dword ptr ds:[edi] &emsp;&emsp;题目提示说这一段代码的函数入口点是在下标为40的点，也就是上面所示的 0048E028 地址的 sub esp,0xC 这一句函数的入口点 模型无法识别，这个函数反编译后的结果其实是一个switch结构，类似如下： 123456789101112131415void test(int arg1)&#123; int a1,a2,a3; ... switch(arg1) &#123; case : break; case : break; case : break; ... &#125;&#125; &emsp;&emsp;题目解析到这里，接下来说说如何解答。 解题方法&emsp;&emsp;首先，我们把样本点输入到模型中，看模型预测的结果，发现每个点输出一个包含2个元素的向量，第1个表示不是入口点的概率，第2个表示是入口点的概率。从输出的结果可以看出，除去第40个点的概率是 [0.722，0.278]，其他基本都是 [1,0]，说明模型差一点就能识别出函数的入口点，而其它的点也没有识别错误。 &emsp;&emsp;模型预测的结果： 12345678910111213[[[ 1.00000000e+00 1.01599495e-09] [ 1.00000000e+00 9.24199650e-09]... [ 1.00000000e+00 2.13964561e-13] [ 1.00000000e+00 8.94351252e-17] [ 1.00000000e+00 1.66032972e-13] [ 7.22238600e-01 2.77761400e-01] # 这个是原始的模型对下标为40的预测结�? [ 1.00000000e+00 1.01078647e-19] [ 1.00000000e+00 4.74433075e-21] [ 1.00000000e+00 1.37062649e-18] [ 1.00000000e+00 1.50506920e-25]... [ 1.00000000e+00 2.42857068e-14]]] &emsp;&emsp;那么，最简单的办法就是将样本点随便改改，然后输入到模型重新训练，应该就能识别。（这里题目没有要求模型需要保证在原始的样本中保持某一个准确度） &emsp;&emsp;我这里将样本点的第0个点 50 改成 49，也就是将第一句的 xor eax,eax 改成 xor al,al ，作为模型的一个训练样本，使用SGD作为优化方法，参数学习率 lr=0.0001, 动量momentum=0.9，使用的迭代次数为10次，并且冻结除RNN的其他层，再重新训练，结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243Epoch 1/101/1 [==============================] - 0s 12ms/step - loss: 0.0064 - acc: 0.9950Epoch 2/101/1 [==============================] - 0s 13ms/step - loss: 0.0063 - acc: 0.9950Epoch 3/101/1 [==============================] - 0s 13ms/step - loss: 0.0060 - acc: 0.9950Epoch 4/101/1 [==============================] - 0s 12ms/step - loss: 0.0057 - acc: 0.9950Epoch 5/101/1 [==============================] - 0s 12ms/step - loss: 0.0053 - acc: 0.9950Epoch 6/101/1 [==============================] - 0s 12ms/step - loss: 0.0048 - acc: 0.9950Epoch 7/101/1 [==============================] - 0s 12ms/step - loss: 0.0044 - acc: 0.9950Epoch 8/101/1 [==============================] - 0s 12ms/step - loss: 0.0039 - acc: 0.9950Epoch 9/101/1 [==============================] - 0s 12ms/step - loss: 0.0035 - acc: 1.0000Epoch 10/101/1 [==============================] - 0s 11ms/step - loss: 0.0031 - acc: 1.0000[[[ 1. 0.] [ 1. 0.]... [ 1. 0.] [ 1. 0.] [ 1. 0.] [ 0. 1.] # 这个是重新训练的模型对下标为40的预测结果 [ 1. 0.] [ 1. 0.] [ 1. 0.] [ 1. 0.]... [ 1. 0.]]] &emsp;&emsp;代码如下： 123456789101112131415161718192021222324252627from keras.optimizers import SGDfrom keras.models import load_modelimport numpy as npdef setup_to_finetune(model): for layer in model.layers: layer.trainable = False model.layers[1].trainable = True # RNN层 不冻结 model.compile(optimizer=SGD(lr=0.0001, momentum=0.9), loss='categorical_crossentropy', metrics=['accuracy'])a = [49,193,132,251,16,16,149,193,142,5,198,9,1,1,1,196,50,193,132,251,16,16,149,193,142,5,198,10,1,1,1,196,145,142,181,39,1,1,1,1,132,237,13,138,93,37,5,50,220,138,117,37,9,138,199,16,183,5,31,233,25,256,256,256,132,249,21,119,12,233,127,59,256,256,142,183,1,1,1,1,256,37,134,169,146,16,9,145,185,4,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,3,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,132,196,2,236,171,142,119,1,185,2,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,6,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,142,183,1,1,1,1,142,189,40,1,1,1,1]x_train = np.array([a])b = [[1,0] for i in range(200)]b[40] = [0,1] # 设置第40位为函数入口点y_train = np.array([b])model = load_model("gcc_O2.h5")setup_to_finetune(model)model.fit(x_train,y_train,batch_size=1,epochs=10) # 重新训练a = [50,193,132,251,16,16,149,193,142,5,198,9,1,1,1,196,50,193,132,251,16,16,149,193,142,5,198,10,1,1,1,196,145,142,181,39,1,1,1,1,132,237,13,138,93,37,5,50,220,138,117,37,9,138,199,16,183,5,31,233,25,256,256,256,132,249,21,119,12,233,127,59,256,256,142,183,1,1,1,1,256,37,134,169,146,16,9,145,185,4,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,3,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,132,196,2,236,171,142,119,1,185,2,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,6,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,142,183,1,1,1,1,142,189,40,1,1,1,1]x_test = np.array([a])print(np.rint(model.predict(x_test))) # 预测model.save("gcc_O2_new.h5") # 保存模型 结束语&emsp;&emsp;感觉这道题的逆向要求不是很高，然后深度学习算法的要求也不是很高，但是两者结合起来感觉挺有意思的。不过，没有其他限制的话，模型是可以过拟合的（只识别一个提供的样本点），为了避免模型过拟合，主办方其实可以提供一些样本，要求新的模型在这些样本下也能够保持准确度。 附件下载]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>AI</tag>
        <tag>看雪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦幻手游部分Luac反编译失败的解决方法]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%A2%A6%E5%B9%BB%E6%89%8B%E6%B8%B8%E9%83%A8%E5%88%86Luac%E5%8F%8D%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这一篇是去年学习破解梦幻西游手游lua代码时记录的一些问题，今天将其整理并共享出来，所以不一定适合现在版本的梦幻手游，大家还是以参考为目的呗。lua相关的文章（共4篇）到此也写完了，如果以后还有新的东西会继续更新，接下来会写几篇关于2018 腾讯游戏安全竞赛的详细分析，敬请期待。 十二处bug修复&emsp;&emsp;当时反编译梦幻西游手游时遇到的问题大约有12个，修改完基本上可以完美复现lua源码，这里用的luadec5.1版本。 修复一&emsp;&emsp;问题1： 由于梦幻手游lua的opcode是被修改过的，之前的解决方案是找到梦幻的opcode，替换掉反编译工具的原opcode，并且修改opmode，再进行反编译。问题是部分测试的结果是可以的，但是当对整个手游的luac字节码反编译时，会出现各种错误，原因是luadec5.1 在很多地方都默认了opcode的顺序，并进行了特殊处理，所以需要找到这些特殊处理的地方一一修改。不过这样很麻烦，从而想到另外一种方式，不修改原来的opcode和opmode，而是在luadec解析到字节码的时候，将opcode还原成原来的opcode。 &emsp;&emsp;解决1： 定位到解析code的位置在 lundump.c –&gt; LoadFunction –&gt; LoadCode （位置不唯一，可以看上一篇腾讯比赛的修复），当执行完LoadCode函数的时候，f变量则指向了code的结构，在这之后执行自己写的函数ConvertCode函数，如下： 123456789101112// add by littleNAvoid ConvertCode(Proto *f)&#123; int pnOpTbl[] = &#123; 3,13,18,36,27,10,20,25,34,2,32,15,30,16,31,9,26,24,29,1,6,28,4,17,33,0,7,11,5,14,8,19,35,12,21,22,23,37 &#125;; for (int pc = 0; pc &lt; f-&gt;sizecode; pc++) &#123; Instruction i = f-&gt;code[pc]; OpCode o = GET_OPCODE(i); SET_OPCODE(i, pnOpTbl[o]); f-&gt;code[pc] = i; &#125;&#125; 修复二&emsp;&emsp;问题2： 在文件头部 反编译出现错误 – DECOMPILER ERROR: Overwrote pending register. &emsp;&emsp;解决2： 分析发现，原来是解析OP_VARARG错误导致的。OP_VARARG主要的作用是复制B-1个参数到A寄存器中，而反编译工具复制了B个参数，多了一个。修改后的代码如下：12345678910111213141516171819... case OP_VARARG: // Lua5.1 specific. &#123; int i; /* * Read ... into register. */ if (b==0) &#123; TRY(Assign(F, REGISTER(a), "...", a, 0, 1)); &#125; else &#123; // add by littleNA // for(i = 0;i&lt;b;i++) &#123; for(i = 0; i &lt; b-1; i++) &#123; TRY(Assign(F, REGISTER(a+i), "...", a+i, 0, 1)); &#125; &#125; break; &#125;... 修复三&emsp;&emsp;问题3： 在解析table出现反编译错误 – DECOMPILER ERROR: Confused about usage of 。registers! &emsp;&emsp;解决3： 分析发现，这里的OP_NEWTABLE 的c参数表示hash table中key的大小，而反编译代码中将c参数进行了错误转换，导致解析错误，修改代码如下： 123// add by littleNA//#define fb2int(x) (((x) &amp; 7) &lt;&lt; ((x) &gt;&gt; 3))#define fb2int(x) ((((x) &amp; 7)^8) &gt;&gt; (((x) &gt;&gt; 3)-1)) 修复四&emsp;&emsp;问题4： 反编译工具出错并且退出。 &emsp;&emsp;解决4： 跟踪发现是在AddToTable函数中，当keyed为0时会调用PrintTable，而PrintTable释放了table，下次再调用table时内存访问失败，修改代码如下： 12345678910111213141516171819202122232425void AddToTable(Function* F, DecTable * tbl, char *value, char *key)&#123; DecTableItem *item; List *type; int index; if (key == NULL) &#123; type = &amp;(tbl-&gt;numeric); index = tbl-&gt;topNumeric; tbl-&gt;topNumeric++; &#125; else &#123; type = &amp;(tbl-&gt;keyed); tbl-&gt;used++; index = 0; &#125; item = NewTableItem(value, index, key); AddToList(type, (ListItem *) item); // FIXME: should work with arrays, too // add by littleNA // if(tbl-&gt;keyedSize == tbl-&gt;used &amp;&amp; tbl-&gt;arraySize == 0)&#123; if (tbl-&gt;keyedSize != 0 &amp;&amp; tbl-&gt;keyedSize == tbl-&gt;used &amp;&amp; tbl-&gt;arraySize == 0) &#123; PrintTable(F, tbl-&gt;reg, 0); if (error) return; &#125;&#125; 修复五&emsp;&emsp; 问题5： 当函数是多值返回结果并且赋值于多个变量时反编译错误，情况如下（lua反汇编）： 1234567821 [-]: GETGLOBAL R0 K9 ; R0 := memoryStatMap22 [-]: GETGLOBAL R1 K9 ; R1 := memoryStatMap23 [-]: GETGLOBAL R2 K2 ; R2 := preload24 [-]: GETTABLE R2 R2 K3 ; R2 := R2["utils"]25 [-]: GETTABLE R2 R2 K16 ; R2 := R2["getCocosStat"]26 [-]: CALL R2 1 3 ; R2,R3 := R2()27 [-]: SETTABLE R1 K15 R3 ; R1["cocosTextureBytes"] := R328 [-]: SETTABLE R0 K14 R2 ; R0["cocosTextureCnt"] := R2 &emsp;&emsp;当上面的代码解析到27行时，从寄存器去取R3时报错，原因是前面的call返回多值时，只是在F-&gt;Rcall中进行了标记，没有在寄存器中标记，编译的结果应该为： 1memoryStatMap.cocosTextureCnt, memoryStatMap.cocosTextureBytes = preload.utils.getCocosStat() &emsp;&emsp; 解决5： 当reg为空时并且Rcall不为空，增加一个return more的标记，修改2个函数： 12345678910111213141516171819202122char *RegisterOrConstant(Function * F, int r)&#123; if (IS_CONSTANT(r)) &#123; return DecompileConstant(F-&gt;f, r - 256); // TODO: Lua5.1 specific. Should change to MSR!!! &#125; else &#123; char *copy; char *reg = GetR(F, r); if (error) return NULL; // add by littleNA // if()&#123;&#125; if (reg == NULL &amp;&amp; F-&gt;Rcall[r] != 0) &#123; reg = "return more"; &#125; copy = malloc(strlen(reg) + 1); strcpy(copy, reg); return copy; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637void OutputAssignments(Function * F)&#123; int i, srcs, size; StringBuffer *vars; StringBuffer *exps; if (!SET_IS_EMPTY(F-&gt;tpend)) return; vars = StringBuffer_new(NULL); exps = StringBuffer_new(NULL); size = SET_CTR(F-&gt;vpend); srcs = 0; for (i = 0; i &lt; size; i++) &#123; int r = F-&gt;vpend-&gt;regs[i]; if (!(r == -1 || PENDING(r))) &#123; SET_ERROR(F,"Attempted to generate an assignment, but got confused about usage of registers"); return; &#125; if (i &gt; 0) StringBuffer_prepend(vars, ", "); StringBuffer_prepend(vars, F-&gt;vpend-&gt;dests[i]); if (F-&gt;vpend-&gt;srcs[i] &amp;&amp; (srcs &gt; 0 || (srcs == 0 &amp;&amp; strcmp(F-&gt;vpend-&gt;srcs[i], "nil") != 0) || i == size-1)) &#123; // add by littleNA // if() if (strcmp(F-&gt;vpend-&gt;srcs[i], "return more") != 0) &#123; if (srcs &gt; 0) StringBuffer_prepend(exps, ", "); StringBuffer_prepend(exps, F-&gt;vpend-&gt;srcs[i]); srcs++; &#125; &#125; &#125;...&#125; 修复六&emsp;&emsp;问题6： 当函数只有一个renturn的时候会反编译错误。 &emsp;&emsp;解决6： 123456789101112131415161718 case OP_RETURN:&#123; ... // add by littleNA // 新增的if if (pc != 0) &#123; for (i = a; i &lt; limit; i++) &#123; char* istr; if (i &gt; a) StringBuffer_add(str, ", "); istr = GetR(F, i); TRY(StringBuffer_add(str, istr)); &#125; TRY(AddStatement(F, str)); &#125; break; &#125; 修复七&emsp;&emsp;问题7： 部分table初始化会出错。 &emsp;&emsp;解决7： 12345678910char *GetR(Function * F, int r)&#123; if (IS_TABLE(r)) &#123; // add by littleNA return "&#123; &#125;"; // PrintTable(F, r, 0); // if (error) return NULL; &#125;...&#125; 修复八&emsp;&emsp;问题8： 可变参数部分解析出错，但是工具反编译时是不报错误的。 &emsp;&emsp;解决8： is_vararg为7时，F-&gt;freeLocal多加了一次： 12345678910if (f-&gt;is_vararg==7) &#123; TRY(DeclareVariable(F, "arg", F-&gt;freeLocal)); F-&gt;freeLocal++;&#125;// add by littleNA// 修改if为else ifelse if ((f-&gt;is_vararg&amp;2) &amp;&amp; (functionnum!=0)) &#123; F-&gt;freeLocal++;&#125; 修复九&emsp;&emsp;问题9： 反编译工具输出的中文为url类型的字符（类似 “\230\176\148\231\150\151\230\156\175”），不是中文。 &emsp;&emsp;解决9： 在proto.c文件中的DecompileString函数中，注释掉default 转换字符串的函数： 123456789101112131415char *DecompileString(const Proto * f, int n)&#123;... default: //add by littleNA// if (*s &lt; 32 || *s &gt; 127) &#123;// char* pos = &amp;(ret[p]);// sprintf(pos, "\\%d", *s);// p += strlen(pos);// &#125; else &#123; ret[p++] = *s;// &#125; break;...&#125; &emsp;&emsp;然后再下面3处增加判断的约束条件，因为中文字符的话，char字节是负数，这样isalpha和isalnum函数就会出错，所以增加约束条件，小于等于127： 12345678910111213141516171819202122232425262728293031323334353637383940void MakeIndex(Function * F, StringBuffer * str, char* rstr, int self)&#123;... int dot = 0; /* * see if index can be expressed without quotes */ if (rstr[0] == '\"') &#123; // add by littleNA // (unsigned char)(rstr[1]) &lt;= 127 &amp;&amp; if ((unsigned char)(rstr[1]) &lt;= 127 &amp;&amp; isalpha(rstr[1]) || rstr[1] == '_') &#123; char *at = rstr + 1; dot = 1; while (*at != '"') &#123; // add by littleNA // *(unsigned char*)at &lt;= 127 &amp;&amp; if (*(unsigned char*)at &lt;= 127 &amp;&amp; !isalnum(*at) &amp;&amp; *at != '_') &#123; dot = 0; break; &#125; at++; &#125; &#125; &#125;....&#125;... case OP_TAILCALL: &#123; // add by littleNA // (unsigned char)(*at) &lt;= 127 &amp;&amp; while (at &gt; astr &amp;&amp; ((unsigned char)(*at) &lt;= 127 &amp;&amp; isalpha(*at) || *at == '_')) &#123; at--; &#125; &#125;... 修复十&emsp;&emsp;问题10： 反汇编失败。因为一些文件中含有很长的字符串，导致sprintf函数调用失败。 &emsp;&emsp;解决10： 增加缓存的大小： 1234567void luaU_disassemble(const Proto* fwork, int dflag, int functions, char* name) &#123; ... // add by littleNA // char lend[MAXCONSTSIZE+128]; char lend[MAXCONSTSIZE+2048];...&#125; 修复十一&emsp;&emsp;问题11： op_setlist操作码当b==0时，反编译失败。 &emsp;&emsp;解决11： 当遇到类似下面的lua语句时，反编译工具会失败，出现的情况在@lib_ui.lua文件中： 1local a=&#123;func()&#125; &emsp;&emsp;汇编后的代码： 123456 a b c[1] newtable 0 0 0 ; array=0, hash=0[2] getglobal 1 0 ; func[3] call 1 1 0[4] setlist 0 0 1 ; index 1 to top[5] return 0 1 &emsp;&emsp;出现的问题有2处，第一个是newtable，当b == 0 &amp;&amp; c == 0时，反编译工具认为table是空的table，直接输出了table并且释放了table的内存，导致后面setlist初始化table时找不到内存而报错。 &emsp;&emsp;第二个是setlist有问题，当b==0时，其实是指寄存器a+1到栈顶（top）的值全部赋值于table，而反编译器没有对b==0的判断，加上就可以了。所以修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void StartTable(Function * F, int r, int b, int c)&#123; DecTable *tbl = NewTable(r, F, b, c); AddToList(&amp;(F-&gt;tables), (ListItem *) tbl); F-&gt;Rtabl[r] = 1; F-&gt;Rtabl[r] = 1; if (b == 0 &amp;&amp; c == 0) &#123; // add by littleNA // for()&#123;&#125; for (int npc = F-&gt;pc + 1; npc &lt; F-&gt;f-&gt;sizecode; npc++) &#123; Instruction i = F-&gt;f-&gt;code[npc]; OpCode o = GET_OPCODE(i); if ((o != OP_SETLIST &amp;&amp; o != OP_SETTABLE) &amp;&amp; r == GETARG_A(i)) &#123; PrintTable(F, r, 1); return; &#125; else if ((o == OP_SETLIST || o == OP_SETTABLE) &amp;&amp; r == GETARG_A(i)) &#123; return; &#125; &#125; PrintTable(F, r, 1); if (error) return; &#125;&#125;void SetList(Function * F, int a, int b, int c)&#123;... // add by littleNA // if()&#123;&#125; if (b == 0) &#123; Instruction i = F-&gt;f-&gt;code[F-&gt;pc-1]; OpCode o = GET_OPCODE(i); if (o == OP_CALL) &#123; int aa = GETARG_A(i); for (i = a + 1; i &lt; aa + 1; i++) &#123; char* rstr = GetR(F, i); if (error) return; AddToTable(F, tbl, rstr, NULL); if (error) return; &#125; &#125; else &#123; for (i = 1;;i++) &#123; char* rstr = GetR(F, a + i); if (rstr == NULL) return; AddToTable(F, tbl, rstr, NULL); if (error) return; &#125; &#125; &#125;...&#125; &emsp;&emsp;StartTable 增加的for循环表示，如果执行了newtable(r 0 0)，后面非初始化table的操作覆盖了r寄存器（把table覆盖了），那就表明new出来的table是空的，后面没有对table的赋值；如果后面有对r寄存器初始化，证明此时new出了的table不是空的，是可变参数的table。 &emsp;&emsp;SetList 增加的if表示，如果指令是call指令，那么将a+1到call指令寄存器aa的栈元素加入到table中（这里为何不是到栈顶的元素而是到aa的元素呢？因为call指令对应的是函数调用，反编译工具已经把函数调用的字符串解析到aa中了，这里跟实际运行可能有点不一样；else后面就是将a+1到栈顶的元素初始化到table中，直到GetR函数为空表示到栈顶了。 修复十二&emsp;&emsp;问题12： 当一个函数开头只是局部变量声明，如： 12345function func() local a,b,c c = f(a,b) return cend &emsp;&emsp;第一行 local a,b,c 会反编译失败，导致后面的代码出现各种错误。 &emsp;&emsp;解决12： 1234567891011121314151617181920void DeclareLocals(Function * F)&#123;... for (i = startparams; i &lt; F-&gt;f-&gt;sizelocvars; i++) &#123; if (F-&gt;f-&gt;locvars[i].startpc == F-&gt;pc) &#123; ... if (PENDING(r)) &#123;...&#125; // add by littleNA // else if()&#123;&#125; else if (locals == 0 &amp;&amp; F-&gt;pc == 0) &#123; StringBuffer_add(str, LOCAL(i)); char *szR = GetR(F, r); StringBuffer_add(rhs, szR==NULL?"nil":szR); &#125; ... &#125; &#125;...&#125; &emsp;&emsp;当变量的startpc 等于 当前pc，变量的个数为0并且当前pc为0，表示第一行声明了变量，添加的else if就是解析这种情况的（原来是直接报错不解析）。 &emsp;&emsp;（完）]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>手游安全</tag>
        <tag>luac反编译</tag>
        <tag>梦幻西游手游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密（后续）]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%EF%BC%88%E5%90%8E%E7%BB%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;趁着周末，把lua的后续文章也写完了。 反编译对抗&emsp;&emsp;众所周知，反汇编/反编译 工具在逆向人员工作中第一步被使用，其地位非常之高，而对于软件保护者来说，如何对抗 反汇编/反编译 就显得尤为重要。例如，动态调试中对OD的的检测、内核调试对windbg的破坏、加壳加花对IDA静态分析的阻碍、apktool的bug导致对修改后的apk反编译失败、修改PE头导致OD无法识别、修改 .Net dll中的区段导致ILspy工具失效等等例子，都说明对抗反编译工具是很常用的一种软件保护手段，当然lua的反编译工具也面临这个问题。处理这样的问题无非就几种思路： 用调试器调试反编译工具为何解析错误，排查原因。 用调试器调试原引擎是如何解析文件的。 用文件格式解析工具解析文件，看哪个点解析出错。 &emsp;&emsp;下面将以3个例子来实战lua反编译是如何对抗与修复。 例子1：一个简单的问题&emsp;&emsp;这是在看雪论坛看到的一个问题，问题是由于游戏（可能是征途手游）将lua字符串的长度int32修改为int64，导致反编译失败的一个例子，修复方法请看帖子中本人的回答，地址：https://bbs.pediy.com/thread-217033.htm 例子2：2018腾讯游戏安全竞赛&emsp;&emsp;这一节以2018腾讯游戏安全竞赛决赛第二题进阶版第1关的题目为例子，主要是讲一下如何修复当lua的opcode被修改的情况，以及如何修复该题对抗lua反编译的问题。 opcode问题及其修复&emsp;&emsp;修复opcode的目的是 当输入题目的luac文件，反汇编工具Chunkspy和反编译工具luadec能够输出正确的结果。 &emsp;&emsp;首先，我们在ida中分析lua引擎tmgs.dll文件，然后定位到luaV_execute函数（搜索字符串“ ‘for’ limit must be a number ”），发现switch下的case的参数（lua的opcode）是乱序的，到这里我们就能够确认，该题的lua虚拟机opcode被修改了。 &emsp;&emsp;接着，我们进行修复操作。一种很耗时的办法就是一个一个opcode还原，分析每一个case下面的代码然后找出对应opcode的顺序。但是这一题我们不用这么麻烦，通过对比分析我们发现普通版的题目并没有修改opcode： 普通版lua引擎的luaV_execute函数 进阶版lua引擎的luaV_execute函数 &emsp;&emsp;观察发现，进阶版的题目只是修改了每个case的数值或者多个值映射到同一个opcode，但是没有打乱case里的代码（也就是说，虚拟机解析opcode代码的顺序没有变，只是修改了对应的数值，这跟梦幻手游的打乱opcode的方法不同）。由于lua5.3只使用到0x2D的opcode，而一个opcode长度为6位（0x3F），该题就将剩余的没有使用的字节映射到同一个opcode下，修复时只需要反过来操作就可以了。分析到这里，我们的修复方案就出来了： 通过ida分别导出2个版本的 luaV_execute 的文本 通过python脚本提取opcode的修复表 在工具（Chunkspy和luadec）初始化lua文件后，用修复表将opcode替换 测试运行，修复其他bug &emsp;&emsp;第一步直接IDA手动导出: File –&gt; Produce file –&gt; Create LST File ；第二步使用python分析，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# 通过扫码IDA导出的文本文件，获取lua字节码的opcode顺序def get_opcode(filepath): f = open(filepath) lines = f.readlines() opcodes = [] # 循环扫码文件的每一行 for i in range(len(lines)): line = lines[i] if line.find('case') != -1: line = line.replace('case', '') line = line.replace(' ', '') line = line.replace('\n','') line = line.replace('u:', '') # 如果上一行也是case，那么这2个case对应同一个opcode if lines[i-1].find('case') != -1: opcode = opcodes[-1] opcode.append(line) else: opcode = [] opcode.append(line) opcodes.append(opcode) f.close() return opcodeso1 = get_opcode(u'基础版opcode.txt')o2 = get_opcode(u'进阶版opcode.txt')# 还原for i in range(len(o1)): print '基础版：',o1[i],'\t进阶版：',o2[i]# 映射opcode获取修复表op_tbl = [-1 for i in range(64)]for i in range(len(o1)): o1opcode = o1[i][0] o1opcode = o1opcode.replace('0x','') for o2opcode in o2[i]: o2opcode = o2opcode.replace('0x','') op_tbl[int(o2opcode,16)] = int(o1opcode,16)print '修复表：',op_tbl &emsp;&emsp;运行结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647基础版： ['0'] 进阶版： ['6', '7', '0x16', '0x1B']基础版： ['1'] 进阶版： ['0x22', '0x28', '0x29', '0x3C']基础版： ['2'] 进阶版： ['0x3E']基础版： ['3'] 进阶版： ['0x3B']基础版： ['4'] 进阶版： ['0x12']基础版： ['5'] 进阶版： ['8', '0x11', '0x17', '0x36']基础版： ['6'] 进阶版： ['2']基础版： ['7'] 进阶版： ['0xD']基础版： ['8'] 进阶版： ['0x1A']基础版： ['9'] 进阶版： ['1']基础版： ['0xA'] 进阶版： ['0x1D']基础版： ['0xB'] 进阶版： ['0x1F']基础版： ['0xC'] 进阶版： ['0xE']基础版： ['0xD'] 进阶版： ['0x31']基础版： ['0xE'] 进阶版： ['0x2F']基础版： ['0xF'] 进阶版： ['0x1E']基础版： ['0x12'] 进阶版： ['0x13']基础版： ['0x14'] 进阶版： ['0x2B']基础版： ['0x15'] 进阶版： ['0x1C']基础版： ['0x16'] 进阶版： ['0x2D']基础版： ['0x17'] 进阶版： ['0x19']基础版： ['0x18'] 进阶版： ['0x3F']基础版： ['0x10'] 进阶版： ['0x15']基础版： ['0x13'] 进阶版： ['0x24']基础版： ['0x11'] 进阶版： ['0x3A']基础版： ['0x19'] 进阶版： ['0x18']基础版： ['0x1A'] 进阶版： ['0x33']基础版： ['0x1B'] 进阶版： ['0xF']基础版： ['0x1C'] 进阶版： ['0x34']基础版： ['0x1D'] 进阶版： ['0x20']基础版： ['0x1E'] 进阶版： ['5', '9', '0xA', '0x25']基础版： ['0x1F'] 进阶版： ['0x30']基础版： ['0x20'] 进阶版： ['0x26']基础版： ['0x21'] 进阶版： ['0x35']基础版： ['0x22'] 进阶版： ['0x38']基础版： ['0x23'] 进阶版： ['0x2A']基础版： ['0x24'] 进阶版： ['0x23', '0x37', '0x39', '0x3D']基础版： ['0x25'] 进阶版： ['0x27']基础版： ['0x27'] 进阶版： ['0x2C']基础版： ['0x28'] 进阶版： ['0x32']基础版： ['0x29'] 进阶版： ['0x21']基础版： ['0x2A'] 进阶版： ['3']基础版： ['0x2B'] 进阶版： ['0xC']基础版： ['0x2C'] 进阶版： ['0x2E']基础版： ['0x2D'] 进阶版： ['0x14']基础版： ['0x26'] 进阶版： ['4']修复表： [-1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24] &emsp;&emsp;注意了，这里有几个opcode是没有对应关系的（默认是-1），跟踪代码发现，其实这些opcode的功能相当于nop操作，而原本lua是不存在nop的，我们只需在修复的过程中跳过这个字节码即可。 &emsp;&emsp;最后将获取的修复表替换到工具中，Chunspy修复点在DecodeInst函数中，修改结果如下：12345678910111213141516171819202122232425262728293031323334353637383940function DecodeInst(code, iValues) local iSeq, iMask = config.iABC, config.mABC local cValue, cBits, cPos = 0, 0, 1 -- decode an instruction for i = 1, #iSeq do -- if need more bits, suck in a byte at a time while cBits &lt; iSeq[i] do cValue = string.byte(code, cPos) * (1 &lt;&lt; cBits) + cValue cPos = cPos + 1; cBits = cBits + 8 end -- extract and set an instruction field iValues[config.nABC[i]] = cValue % iMask[i] cValue = cValue // iMask[i] cBits = cBits - iSeq[i] end -- add by littleNA local optbl = &#123; -1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24 &#125; iValues.OP = optbl[iValues.OP+1] -- 注意，lua的下标是从1开始的数起的 -- add by littleNA end iValues.opname = config.opnames[iValues.OP] -- get mnemonic iValues.opmode = config.opmode[iValues.OP] -- add by littleNA if iValues.OP == -1 then iValues.opname = "Nop" iValues.opmode = iABx end -- add by littleNA end if iValues.opmode == iABx then -- set Bx or sBx iValues.Bx = iValues.B * iMask[3] + iValues.C elseif iValues.opmode == iAsBx then iValues.sBx = iValues.B * iMask[3] + iValues.C - config.MAXARG_sBx elseif iValues.opmode == iAx then iValues.Ax = iValues.B * iMask[3] * iMask[2] + iValues.C * iMask[2] + iValues.A end return iValuesend &emsp;&emsp;测试发现出错了，出错结果： &emsp;&emsp;从出错的结果可以看出是luac文件的版本号有错误，这里无法识别lua 11的版本其实是题目故意设计让工具识别错误，我们将文件的第4个字节（lua版本号）11修改成53就可以了。正确结果： &emsp;&emsp;luadec修复点在ldo.c文件的f_parser函数，并且增加一个RepairOpcode函数，修复如下：1234567891011121314151617181920212223242526272829303132333435363738394041// add by littleNAvoid RepairOpcode(Proto* f)&#123; // opcode 替换表 char optbl[] = &#123; -1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24 &#125;; for (int i = 0; i &lt; f-&gt;sizecode; i++) &#123; Instruction code = f-&gt;code[i]; OpCode o = GET_OPCODE(code); SET_OPCODE(code, optbl[o]); f-&gt;code[i] = code; &#125; for (int i = 0; i &lt; f-&gt;sizep; i++) &#123;// 处理子函数 RepairOpcode(f-&gt;p[i]); &#125;&#125;// add by littleNA endstatic void f_parser (lua_State *L, void *ud) &#123; LClosure *cl; struct SParser *p = cast(struct SParser *, ud); int c = zgetc(p-&gt;z); /* read first character */ if (c == LUA_SIGNATURE[0]) &#123; checkmode(L, p-&gt;mode, "binary"); cl = luaU_undump(L, p-&gt;z, p-&gt;name); // add by littleNA Proto *f = cl-&gt;p; RepairOpcode(f); // add by littleNA end &#125; else &#123; checkmode(L, p-&gt;mode, "text"); cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c); &#125; lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues); luaF_initupvals(L, cl);&#125; &emsp;&emsp;运行一下，发现出错了，并且停留在StringBuffer_add函数中，其中str指向错误的地方，导致字符串读取出错： &emsp;&emsp;到这里我们修复了opcode，并且Chunkspy顺利反汇编，但是luadec的反编译还是有问题，我们在下一节分析。 反编译问题及其修复&emsp;&emsp;看了几个大佬的writeup，发现他们都没有修复这个问题，解题过程中都是直接分析的是lua汇编代码。我们看看出错的原因，查看vs的调用堆栈： &emsp;&emsp;发现上一层函数是listUpvalues函数，也就是说luadec在解析upvalues时出错了，深入分析发现其实是由于文件中的upvalue变量名被抹掉了，导致解析出错，我们只需要在ProcessCode函数（decompile.c文件）调用listUpvalues函数前，增加临时的upvalue命名就可以了，修改代码如下： 123456789101112131415161718char* ProcessCode(Proto* f, int indent, int func_checking, char* funcnumstr) &#123;... // make function comment StringBuffer_printf(str, "-- function num : %s", funcnumstr); if (NUPS(f) &gt; 0) &#123; // add by littleNA for (i = 0; i&lt;f-&gt;sizeupvalues; i++) &#123; char tmp[10]; sprintf(tmp, "up_%d", i); f-&gt;upvalues[i].name = luaS_new(f-&gt;L, tmp); &#125; // add by littleNA end StringBuffer_add(str, " , upvalues : "); listUpvalues(f, str); &#125;...&#125; &emsp;&emsp;最后完美运行luadec，反编译成功。 例子3：梦幻西游手游&emsp;&emsp;这个例子内容较多，并且这篇文章也够长了，索性就把这节单独写成一篇文章。]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密（前传）]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%EF%BC%88%E5%89%8D%E4%BC%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;为了能让一些同学更好的学习lua的逆向，我把收集的一些资料组合成一篇lua加解密的相关工作给大家参考，当然，看这篇文章之前还是需要一些lua的基础知识，这里推荐云风大佬的《Lua源码欣赏》[19]，建议结合搜索引擎学习之。 &emsp;&emsp;文章分2部分介绍，第1部分介绍lua加解密的相关文章介绍，第2部分介绍lua的相关工具。 相关工作：&emsp;&emsp;这一节介绍了互联网上对lua的各种相关文章，包括lua的加解密如文件格式的解析、基于lua的游戏和比赛的介绍、lua的hook技术等。 1. lua加解密入门： &emsp;&emsp;非虫大佬[1-4] 写了4篇关于luac和luajit文件格式和字节码的相关文章，并开源了010Editor的解析luac和luajit的模板代码。Ganlv 同学[7] 在吾爱破解写了7篇关于lua加解密的系列教程。腾讯gslab[9] 写了一篇关于lua游戏逆向的入门介绍，这是一篇比较早的lua游戏解密的文章。INightElf 同学[10] 写了一篇关于lua脚本反编译入门的文章。 2. 基于lua的手游： &emsp;&emsp;lua不仅能用于端游戏，也能用于手游，而且由于手游的火热，带动了lua逆向相关分析文章的分享。wmsuper 同学[11] 在android平台下解密了腾讯游戏开心消消乐的lua脚本，后续可以通过修改lua脚本达到作弊的目的。Unity 同学[8] 通过hook的方法解密和修改lua手游《放置江湖》的流程，达到修改游戏奖励的目的。littleNA 同学[12] 通过3种方式解密了3个手游的lua脚本，并且修复了梦幻手游lua opcode的顺序。 3. 基于lua的比赛： &emsp;&emsp;随着国内CTF的发展，lua技术也运用到了比赛中。看雪ctf2016第2题[13]、2017第15题[14]和腾讯游戏安全2018决赛第2题[15]都使用了lua引擎作为载体的CrackMe比赛，其中看雪2016将算法验证用lua代码实现并编译成luac，最后还修改了luac的文件头，使得反编译工具报错；看雪2017的题使用壳和大量的混淆，最后一步是luajit的简单异或运算；腾讯2018使用的lua技术更加深入，进阶版更是修改了lua的opcode顺序，并使用lua编写了一个虚拟机。以上3题的writeup网上都可以搜索到，有兴趣的朋友可以练练手，加深印象。 4. lua hooking： &emsp;&emsp;Hook是修改软件流程的常用手段，lua中也存在hook技术。曾半仙 同学[9] 在看雪发布了一种通过hook lua字节码达到修改游戏逻辑的方法，并发布了一个lua汇编引擎。Nikc Cano[5] 的blog写了一篇关于Hooking luajit的文章，興趣使然的小胃 同学[6] 对该篇文章进行了翻译。 工具介绍：&emsp;&emsp;逆向解密lua和luajit游戏都有相关的工具，这一节将对一些主流的工具进行介绍。 1. lua相关： luadec [16]：这是一个用c语言结合lua引擎源码写的开源lua反编译器，解析整个lua字节码文件并尽可能的还原为源码。当然，由于还原的是高级语言，所以兼容性一般，当反编译大量文件时肯定会遇到bug，这时就需要自己手动修复bug；并且很容易被针对造成反编译失败。目前支持的版本有lua5.1，5.2和5.3。 chunkspy：一款非常有用的lua分析工具，本身就是lua语言所写。它解析了整个lua字节文件，由于其输出的是lua的汇编形式，所以兼容性非常高，也造成了一定的阅读障碍。chunkspy 不仅可以解析luac文件，它还包括了一个交互式的命令，可以将输入的lua脚本转换成lua字节码汇编的形式，这对学习lua字节码非常有帮助。luadec工具中集成了这个脚本，目前支持的版本也是有lua5.1，5.2和5.3。 unluac：这也是一个开源的lua反编译器，java语言所写，相比luadec 工具兼容性更低,。一般很少使用，只支持lua5.1，当上面工具都失效时可以尝试。 2. luajit相关： luajit-decomp[17]：github开源的一款luajit反编译工具，使用au3语言编写。先通过luajit原生的exe文件将luajit字节码文件转换成汇编，然后该工具再将luajit汇编转换成lua语言。由于反汇编后的luajit字节码缺少很多信息，如变量名、函数名等，造成反编译后的结果读起来比较隐晦，类似于ida的F5。但是兼容性超好，只要能够反汇编就能够反编译，所以使用时需要替换对应版本的luajit引擎（满足反汇编的需求）。目前是支持所有的luajit版本。 ljd[18]：也是github开源的一款luajit反编译工具，使用python编写，与luajit-decomp 反编译luajit汇编的方式不同，其从头解析了整个luajit文件，能够获取更多的信息，还原的程度更高，但是由于精度更高，所以兼容性也会弱一点。查看该项目的fork可以获取更多的其他兼容版本，目前支持的版本有luajit2.0、luajit2.1等。 参考文章 [1] 飞虫 《Lua程序逆向之Luac文件格式分析》 https://www.anquanke.com/post/id/87006 [2] 飞虫 《Lua程序逆向之Luac字节码与反汇编》 https://www.anquanke.com/post/id/87262 [3] 飞虫 《Lua程序逆向之Luajit文件格式》 https://www.anquanke.com/post/id/87281 [4] 飞虫 《Lua程序逆向之Luajit字节码与反汇编》 https://www.anquanke.com/post/id/90241 [5] Nick Cano 《Hooking LuaJIT》 https://nickcano.com/hooking-luajit [6] 興趣使然的小胃 《看我如何通过hook攻击LuaJIT》 https://www.anquanke.com/post/id/86958 [7] Ganlv 《lua脚本解密1：loadstring》 https://www.52pojie.cn/thread-694364-1-1.html [8] unity 《【放置江湖】LUA手游 基于HOOK 解密修改流程》 https://www.52pojie.cn/thread-682778-1-1.html [9] 游戏安全实验室 《Lua游戏逆向及破解方法介绍》 http://gslab.qq.com/portal.php?mod=view&amp;aid=173 [10] INightElf 《[原创]Lua脚本反编译入门之一》 https://bbs.pediy.com/thread-186530.htm [11] wmsuper 《开心消消乐lua脚本解密》 https://www.52pojie.cn/thread-611248-1-1.html [12] littleNA 《浅析android手游lua脚本的加密与解密》 https://bbs.pediy.com/thread-216969.htm [13] 《看雪 2016CrackMe 第二题》 https://ctf.pediy.com/game-fight-3.htm [14] 《看雪 2017CrackMe 第十五题》 https://ctf.pediy.com/game-fight-45.htm [15] 《腾讯游戏安全技术竞赛》 https://www.52pojie.cn/forum-77-1.html [16] luadec https://github.com/viruscamp/luadec [17] ljd https://github.com/NightNord/ljd [18] luajit-decomp https://github.com/bobsayshilol/luajit-decomp [19] 云风 《Lua源码欣赏》 https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/luadec/云风-lua源码欣赏-lua-5.2.pdf]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;博客刚刚弄完善，把去年发在看雪的一篇精华帖转了过来，文章稍微修改了下，并且增加了后续文章，希望能够吸引点人气。这篇文章是我在学习android手游安全时总结的一篇关于lua的文章，不足之处欢迎指正，也欢迎各位大佬前来交流。 &emsp;&emsp;主要用到的工具和环境： win7系统 cocos2d-x 开发环境 IDA6.8 vs2015 AndroidKiller 1.3.1 luadec51 luajit-decomp… lua 现状分析&emsp;&emsp;去年的那篇文章这一章没有写的，今年补上了一篇lua加解密的相关工作，请看：《浅析android手游lua脚本的加密与解密（前传）》 lua 各文件关系&emsp;&emsp;在学习lua手游解密过程中，遇到的lua文件不外乎就3种。其中.lua后缀的文件是明文代码，直接用记事本就能打开，.luac是lua脚本编译后的字节码文件，文件头为0x1B 0x4C 0x75 0x61，lua虚拟机能够直接解析lua和luac脚本文件，而.luaJIT是另一个lua的实现版本（不是lua的原作者写的），JIT是指Just-In-Time（即时解析运行），luaJIT相比lua和luac更加高效，文件头是0x1B 0x4C 0x4A： &emsp;&emsp;luac 文件头如下： &emsp;&emsp;luaJIT 文件头如下： lua 脚本保护&emsp;&emsp;一般有安全意识的游戏厂商都不会直接把lua源码脚本打包到APK中发布，所以一般对lua脚本的保护有下面3种： 1. 普通的对称加密，在加载脚本之前解密 &emsp;&emsp;这种情况是指打包在APK中的lua代码是加密过的，程序在加载lua脚本时解密（加载脚本的关键函数luaL_loadbuffer），解密后就能够获取lua源码。如果解密后获取的是luac字节码的话，也可以通过对应的反编译得到lua源码，反编译主要用的工具有unluac和luadec51，后面会具体分析。 2. 将lua脚本编译成luaJIT字节码并且加密打包 &emsp;&emsp;因为cocos2d-x使用的luaJIT，而且luaJIT反编译后的结果阅读起来比较麻烦，所以这种情况能够较好的保护lua源码。这个情况主要是先解密后反编译，反编译主要是通过luajit-decomp项目，它能够将luajit字节码反编译成伪lua代码。 3. 修改lua虚拟机中opcode的顺序 &emsp;&emsp;这种情况主要是修改lua虚拟机源码，再通过修改过的虚拟机将lua脚本编译成luac字节码，达到保护的目的。这种情况如果直接用上面的反编译工具是不能将luac反编译的，需要在虚拟机的引擎中分析出相对应的opcode，然后修复反编译工具luadec 源码中的 opcode 并重新编译，编译后的文件就能进行反编译了，后面会具体分析。 &emsp;&emsp;在破解手游过程中，上面的三种情况可能会交叉遇到。 获取lua源码的一般方法&emsp;&emsp;这里主要介绍4种方法，都会在后面用实例说明。 1. 静态分析so解密方法 &emsp;&emsp;这种方法需要把解密的过程全部分析出来，比较费时费力，主要是通过ida定位到luaL_loadbuffer函数，然后往上回溯，分析出解密的过程。 2. 动态调试：ida + idc + dump &emsp;&emsp;游戏会在启动的时候通过调用 luaL_loadbuffer函数加载必要的lua脚本，我们可以通过ida动态调试so文件，然后是定位到luaL_loadbuffer地址，再下断点 ，断下后就接着运行idc脚本（或者python脚本）将lua代码导出（程序调用一次luaL_loadbuffer只加载一个lua脚本，所以需要编写idc脚本自动保存lua代码）。 3. hook so &emsp;&emsp;跟4.2原理一样，就是通过hook函数luaL_loadbuffer地址，将lua代码保存，相比4.2的好处是有些lua脚本需要在玩游戏的过程中才加载，如果用了4.2的方法，那么在游戏过程中需要加载新的lua文件就会中断一次，我们就需要手动运行一次idc脚本，如果是hook的话，就不需要那么麻烦，直接玩一遍游戏，全部lua脚本就已经保存好了。 4. 分析lua虚拟机的opcode的顺序 &emsp;&emsp;这里主要是opcode的顺序被修改了，需要用ida定位到虚拟机执行luac字节码的地方，然后对比原来lua虚拟机的执行过程，获取修改后的opcode顺序，最后还原lua脚本。 &emsp;&emsp;综上，静态分析费时费力但是能够解密全部的lua脚本，而通过动态获取的方法虽然方便，但是只能获取游戏当前需要加载的lua脚本。具体选择哪种方法，需要衡量时间成本等。 lua脚本解密实例分析&emsp;&emsp;接着用3个游戏作为实例说明上面分析的情况。 54捕鱼&emsp;&emsp;首先用AndroidKiller 加载，然后查看lib目录下的so文件，发现libcocos2dlua.so文件，基本可以确定是lua脚本编写的了。这里有个小技巧，当有很多so文件的时候，一般最大的文件是我们的目标（文件大是因为集成了lua引擎，既然有lua引擎，那么肯定有lua脚本了）。接着找lua脚本，资源文件和lua脚本文件都是在assets目录下。我们发现这个游戏的资源文件和配置文件都是明文，这里直接修改游戏的配置文件就可以作弊（比如修改升级炮台所需的金币和钻石，就可以达到快速升级炮台的目的），然后并没有发现类似lua脚本的文件。 &emsp;&emsp;顺手解压了一下res目录下的liveupdate_precompiled.zip，发现解压失败，看来是加密了（看文件名字知道是更新游戏的代码）这里说明一下，一般遇到xxxx_precompiled.zip的这种文件，都是quick-cocos2d-x框架（quick简单来说就是对lua的拓展实现），在quick-cocos2d-x框架下可以用compile_scripts命令将lua文件加密打包成xxxx_precompiled.zip，游戏运行时再解密加载。注意，这种方式打包的lua脚本一般都会被编译成luaJIT字节码，加载的关键函数是loadChunksFromZIP，可以在IDA中直接搜索该函数，如果找不到可以搜索字符串luaLoadChunksFromZIP来定位到函数 &emsp;&emsp;OK，了解了原理接下来开始动手分析，将libcocos2dlua.so拖到IDA中加载，函数中直接搜索loadChunksFromZIP，定位后F5分析。 &emsp;&emsp;对该函数一直向上回溯（交叉引用 ），来到下图，发现解密的密钥和签名，其中xiaoxian为密钥，XXFISH为签名 &emsp;&emsp;进去函数里面看看，其实会发现调用了XXTea算法，这里我们也可以直接分析loadChunksFromZIP函数的源码（所以配置一个cocos2d的开发环境还是非常有必要的）。查看源码里的lua_loadChunksFromZIP函数的原型：12345678910111213141516171819202122232425int CCLuaStack::lua_loadChunksFromZIP(lua_State *L)&#123; if (lua_gettop(L) &lt; 1) &#123; // 这里可以发现用字符串也可以定位到目标函数 CCLOG("lua_loadChunksFromZIP() - invalid arguments"); return 0; &#125;... if (isXXTEA) &#123; // decrypt XXTEA // 这里调用了解密函数 xxtea_long len = 0; buffer = xxtea_decrypt(zipFileData + stack-&gt;m_xxteaSignLen, (xxtea_long)size - (xxtea_long)stack-&gt;m_xxteaSignLen, (unsigned char*)stack-&gt;m_xxteaKey, (xxtea_long)stack-&gt;m_xxteaKeyLen, &amp;len); delete []zipFileData; zipFileData = NULL; zip = CCZipFile::createWithBuffer(buffer, len); &#125;...&#125; &emsp;&emsp;接下来直接写解密函数（在cocos2d-x项目里面写的解密函数，很多工具类直接可以调用）12345678910111213141516171819202122232425262728293031323334353637383940void decryptZipFile_54BY(string strZipFilePath)&#123; CCFileUtils *utils = CCFileUtils::sharedFileUtils(); unsigned long lZipFileSize = 0; unsigned char *szBuffer = NULL; unsigned char *zipFileData = utils-&gt;getFileData(strZipFilePath.c_str(), "rb", &amp;lZipFileSize); xxtea_long xxBufferLen = 0; szBuffer = xxtea_decrypt(zipFileData + 6, //6为签名XXFISH的长度 (xxtea_long)lZipFileSize - (xxtea_long)6, //减去签名的长度 (unsigned char*)"xiaoxian", //xiaoxian为密钥 (xxtea_long)8, //密钥的长度 &amp;xxBufferLen); //获取zip里面的所有文件 CCZipFile *zipFile = CCZipFile::createWithBuffer(szBuffer, xxBufferLen); int count = 0; string strFileName = zipFile-&gt;getFirstFilename(); while (strFileName.length()) &#123; cout &lt;&lt; "filename:" &lt;&lt; strFileName &lt;&lt; endl; unsigned long lFileBufferSize = 0; unsigned char *szFileBuffer = zipFile-&gt;getFileData(strFileName.c_str(), &amp;lFileBufferSize); if (lFileBufferSize) &#123; ++count; ofstream ffout(strFileName, ios::binary); ffout.write((char *)szFileBuffer, sizeof(char) * (lFileBufferSize)); ffout.close(); delete[] szFileBuffer; &#125; strFileName = zipFile-&gt;getNextFilename(); &#125; delete[] zipFileData;&#125; &emsp;&emsp;解密后的文件如下： &emsp;&emsp;这几个都是更新游戏的代码，是luajit的文件，所以接下来需要反编译。反编译需要确定lua和luajit的版本，我们通过IDA查看下lua版本和luajit版本，字符串中分别搜索lua+空格和luajit+空格： &emsp;&emsp;lua版本为5.1 &emsp;&emsp;luajit版本为2.1.0 &emsp;&emsp;这篇文章反编译用到的是luajit-decomp，这里需要注意，luajit-decomp默认的lua 5.1 和luajit 2.0.2，我们需要下载对应lua和luajit的版本，编译后替换luajit-decomp下的lua51.dll、luajit.exe、jit文件夹。反编译时需要替换的文件和文件夹如下： &emsp;&emsp;对于这个游戏，我们需要下载版本为2.1.0-beta2的luajit，并且编译生成文件后，复制LuaJIT-2.1.0-beta2\src路径下的lua51.dll、luajit.exe文件和jit文件夹覆盖到luajit-decomp目录中。luajit-decomp用的是autolt3语言，原脚本默认是只反编译当前目录下的test.lua文件，所以需要修改decoder.au3文件的代码。修改后的代码另存为jitdecomp.au3文件，接着编译au3代码为jitdecomp.exe。我这里还增加了data目录，该目录下有3个文件夹，分别为： luajit：待反编译的luajit文件 asm：反汇编后的中间结果 out：反编译后的结果 &emsp;&emsp;将解密后的文件放到luajit文件夹，运行 jitdecomp.exe，反编译的结果在out目录下，结果如下： &emsp;&emsp;这个反编译工具写得并不好，反编译后的lua文件阅读起来相对比较困难，而且反编译的lua格式有问题，所以不能用lua编辑器格式化代码。 捕鱼达人4&emsp;&emsp;这个游戏主要是用ida动态调试so文件，然后用idc脚本把lua文件全部dump下来的方法。首先用AndroidKiller加载apk，在lib目录下有3个文件夹，不同的手机cpu型号对应不同的文件夹 。本人的手机加载的目标so文件在armeabi-v7a文件下： &emsp;&emsp;接着，ida加载libcocos2dlua.so文件，定位到函数luaL_loadbuffer，可以在函数中直接搜索，也可以字符串搜索 “[LUA ERROR]” 来定位到函数中，函数分析如下： 1LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,const char *name) &emsp;&emsp;所以在ARM汇编中，参数R0为lua_State指针，参数R1为脚本内容，R2为脚本大小，R3为脚本的名称，写一段IDC脚本dump数据即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;idc.idc&gt;static main()&#123; auto code, bp_addrese,fp,strPath,strFileName; bp_addrese = 0x7573022C; // luaL_loadbuffer函数地址 AddBpt(bp_addrese); // 下断点，也可以手动下断 while(1) &#123; code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, 15); // 等待断点发生，等待时间为15秒 if ( code &lt;= 0 ) &#123; Warning("错误代码：%d",code); return 0; &#125; Message ("地址：%a, 事件id：%x\n", GetEventEa(), GetEventId()); // 断点发生，打印消息 strFileName = GetString(GetRegValue("R3"),-1,0); // 获取文件路径名 strFileName = substr(strFileName,strrstr(strFileName,"/")+1,-1); // 获取最后一个‘/’后面的名字（文件的名字）去掉路径 strPath = sprintf("c:\\lua\\%s",strFileName); // 保存lua的本地路径 fp = fopen(strPath,"wb"); savefile(fp,0,GetRegValue("R1"),GetRegValue("R2")); fclose(fp); Message("保存文件成功: %s\n",strPath); &#125;&#125;//字符串查找函数，从后面向前查找，返回第一次查找的字符串下标static strrstr(str,substr1)&#123; auto i,index; index = -1; while (1) &#123; i = strstr(str,substr1); if (-1 == i) return index; str = substr(str,i+1,-1); index = index+i+1; &#125;;&#125; &emsp;&emsp;ida动态调试so文件网上有很多文章，这里就不详细说明了。通过idc脚本获取的部分数据如下： &emsp;&emsp;虽然文件的后缀名是.luac，但其实都是明文的lua脚本。 梦幻西游手游&emsp;&emsp;AndroidKiller反编译apk，查看lib下存在libcocos2dlua.so，基本上确定是lua写的： &emsp;&emsp;在assets\HashRes目录下，存在很多被加密的文件，这里存放的是lua脚本和游戏的其他资源文件： &emsp;&emsp;接着找lua脚本的解密过程，用ida加载libcocos2dlua.so文件，搜索luaL_loadbuffer函数，定位到关键位置，这里就是解密的过程了： &emsp;&emsp;分析解密lua文件过程如下： &emsp;&emsp;这里需要实现Lrc4解密的相关函数，还有Lzma解压函数需要自己实现，其他几个都是cocos2d平台自带的函数，直接调用就可以了。上面的流程图实现的函数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool decryptLua_Mhxy(string strFilePath, string strSaveDir)&#123; bool bResult = false; char *szBuffer = NULL; int nBufferSize = 0; CCFileUtils *utils = CCFileUtils::sharedFileUtils(); unsigned long ulFileSize = 0; char *szFileData = (char*)utils-&gt;getFileData(strFilePath.c_str(), "rb", &amp;ulFileSize); if (strncmp(szFileData, "L:grxx", 6)) &#123; if (!strncmp(szFileData, "__sign_of_g18_enc__", 0x13)) &#123; szBuffer = szFileData + 0x13; nBufferSize = ulFileSize - 0x13; bResult = decrypt((unsigned char*)szBuffer, nBufferSize); &#125; &#125; else if (!strncmp(szFileData + 6, "__sign_of_g18_enc__", 0x13)) &#123; unsigned char *pData = (unsigned char *)szFileData + 0x19; int nLen = ulFileSize - 0x19; bResult = decrypt(pData, nLen); if (ZipUtils::isGZipBuffer(pData, nLen)) &#123; nBufferSize = ZipUtils::ccInflateMemory(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else if (ZipUtils::isCCZBuffer(pData, nLen)) &#123; nBufferSize = ZipUtils::inflateCCZBuffer(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else if (LzmaUtils::isLzmaBuffer(pData, nLen)) &#123; nBufferSize = LzmaUtils::inflateLzmaBuffer(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else &#123; bResult = false; &#125; &#125; if(bResult) saveLuaData(szBuffer, nBufferSize, strSaveDir); return bResult;&#125; &emsp;&emsp;解密函数过程如下： &emsp;&emsp;decrypt()实现代码如下： 1234567bool decrypt(unsigned char *pData, int nLen)&#123; Lrc4 *pLrc4 = new Lrc4; Lrc4_lrc4(pLrc4); Lrc4_s(pLrc4, pData, nLen); return true;&#125; &emsp;&emsp;Lrc4结构如下: 12345678#define DATA_SIZE 256struct Lrc4&#123; unsigned char pData[DATA_SIZE]; //初始化时计算得到的256个字节 int nIndex; //记录下标 int nPreIndex; //记录前一个下标&#125;; &emsp;&emsp;其他函数的具体实现请看DecryptData_Mhxy.cpp文件，这里就不贴代码了。解密后的文件如下： &emsp;&emsp;可以看出，解密后的文件为luac字节码，但是这里直接用反编译工具是不能反编译luac字节码的，因为游戏的opcode被修改过了，我们需要找到游戏opcode的顺序，然后生成一个对应opcode的luadec.exe文件才能反编译。下表为修改前后的opcode： &emsp;&emsp;lua虚拟机的相关内容就不说明了，百度很多，这里说明下如何还原opcode的顺序。首先需要定位到opmode的地方，IDA搜索字符串”LOADK”，定位到opname的地方，交叉引用到代码，找到opmode： &emsp;&emsp;off_B02CEC为opname的地址，byte_A67C00为opmode的地址，进入opmode地址查看： &emsp;&emsp;这里没有把全部数据截图出来，可以看出，这里的opmode跟原opmode是不对应的。原opmode在lua源码中的lopcodes.c文件中： &emsp;&emsp;源码用了宏，计算出来的结果就是上表中opmode的结果。这里对比opmode就可以快速对比出opcode，因为opmode不相等，那么opcode也肯定不相等，到这一步，已经能还原部分opcode了，因为有一些opmode是唯一的。比如下面几个： &emsp;&emsp;如SETLIST，原opcode为34，opmode为0x14，找到的opmode的第8个字节也为0x14，则实际上SETLIST的opcode为8。 &emsp;&emsp;接下来就需要定位到luaV_execute函数，然后对比源码来还原其他的opcode，直接IDA搜索字符串”initial value must be a number”可以定位到luaV_execute 函数，再F5一下。接着打开lua源码中的lvm.c文件，找到luaV_execute函数，就可对比还原了。lua源码和IDA F5后的代码其实差别还是有的，而且源码用了大量的宏，所以源码只是用来参考、理解lua虚拟机的解析过程，本人在还原的过程中，会再打开一个没有修改opcode的libcocos2dlua.so文件，这样对比查找就方便多了。 &emsp;&emsp;最后修改lua源码 lopcodes.h中的opcode、lopcodes.c的opname和opmode，重新编译并生成luadec51 .exe（需要将lua源码中的src目录放到luadec51的lua目录下才能编译），就OK了，写个批处理文件就可以批量反编译。一个文件反编译的结果： 总结&emsp;&emsp;总结一下解密lua的流程，拿到APK，首先反编译，查看lib目录下是否有libcocos2dlua.so，存在的话很大可能这个游戏就是lua编写，其中lib目录下文件最大的就是目标so文件，一般情况就是libcocos2dlua.so。接着再看assert文件夹有没有可疑的文件，手游的资源文件会放到这个文件夹下，包括lua脚本。其次分析lua加密的方式并选择解密脚本的方式，如果可以ida动态调试，一般都会选择用idc脚本dump下lua代码。最后如果得到的不是lua明文，还需要再反编译一下。 &emsp;&emsp;不足之处：luajit的反编译并不完美，用的是luajit-decomp反编译工具，工具的作者也说只是满足了他自己的需求，还有一个luajit反编译是python写的工具ljd。其次梦幻luac的反编译部分代码反编译失败，修复过程请看这篇文章。 参考文章 腾讯游戏安全中心 《Lua游戏逆向及破解方法介绍》 http://gslab.qq.com/portal.php?mod=view&amp;aid=173 云风 《Lua源码欣赏》 https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/luadec/云风-lua源码欣赏-lua-5.2.pdf FSD-BlueEffie的博客 《梦幻西游手游 美术资源加密分析》 http://blog.csdn.net/blueeffie/article/details/50971665 Kaitiren的专栏 《Quick-cocos2d-x 与Cocos2dx 区别》 http://blog.csdn.net/kaitiren/article/details/35276177]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
</search>
