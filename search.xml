<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[阅读笔记]《AVPASS: Automatically Bypassing Android Malware Detection System》]]></title>
    <url>%2F2018%2F09%2F30%2F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E3%80%8AAVPASS-Automatically-Bypassing-Android-Malware-Detection-System%E3%80%8B%2F</url>
    <content type="text"><![CDATA[Black Hat 2017 AVPASS系统的研究报告——一个自动化逃逸android恶意软件检测的系统 &emsp;&emsp;最近各界对AI模型的安全性和鲁棒性进行了深入的探讨，如何生成和检测对抗样本也慢慢进入大众视野。恶意软件的对抗其实是经久不衰的话题，从PC端的免杀到移动端的逃逸，一直在发展。为此笔者分析了在BlackHat 2017上开源的一个关于android恶意软件检测自动化逃逸的工具AVPASS，本文是结合该工具的演讲PPT、演讲视频和开源代码的研究报告。 简介：&emsp;&emsp;该议题是发表于BlackHat2017会议的一篇关于android对抗性样本自动生成的议题，主要使用了混淆的方法来逃逸静态方法的检测。目标是 1）自动化推断反病毒引擎检测移动恶意软件的特征，2）最小程度的混淆恶意样本的这些特征以逃过检测。议题中首先讲解了什么混淆，并且混淆是如何阻止逆向人员分析的。接着讲述了4个学术界检测apk的知名方法：基于API、基于数据流、基于组件、基于签名，并且讲述如何逃逸这些检测引擎。最后议题将工具运用到现实中，以VirusTotal上的检测引擎作为目标，自动推断出反病毒厂家常用的检测特征，并且逃逸这些引擎。 开场：&emsp;&emsp;开场举了Defcon 24的一个例子：拿一个使用了CVE-2012-4681漏洞的公开的恶意样本，分别在2014年和2016年使用VT对其进行检测，2次都大约有50%的厂家报毒，但是当样本被修改了一点点的信息，就可以绕过这些反病毒厂家的引擎。 混淆：&emsp;&emsp;整个AVPASS主要使用混淆的手动来达到逃逸的效果。混淆时需要确保2点： 保证原始apk的功能 混淆后的代码很难被反混淆和逆向： 增加混淆的复杂度 使用Java反射手段隐藏所有的API 使用不同的key加密所有的字符串 多次混淆 &emsp;&emsp;一个混淆防止逆向人员分析的例子： 混淆前 混淆后 已知检测方法及逃逸（学术界）：&emsp;&emsp;一个简单的短信拦截木马的实例代码： &emsp;&emsp;上图示例说明，在中了短信拦截木马的手机上，木马拦截一条短信的大概过程。首先系统收到短信后，会广播一条收到短信的消息，而注册了相关广播接收器（BroadcastReceiver）的应用都能够收到这条消息，木马也不例外。当木马的InterceptSMS组件收到消息的时候，会读取短息的内容和手机号，并将结果发送到后台运行的SendToNetwork组件（Service服务），该组件将收到的内容发送到远程服务器。当黑客收到短信时，整一个短信泄露的过程就完成了。 &emsp;&emsp;接着，作者简要介绍了4种检测android恶意软件的方法，并针对性的进行恶意样本逃逸，最给出了逃逸的效果。（本文在4种检测方法的内容上进行了一定程度的扩充） 基于API&emsp;&emsp;基于API其实就是提取APK中使用到的API或者API序列作为特征，然后使用机器学习的算法进行分类，最后生成一个可用的模型。例如DroidMat（提取权限和API作为特征，使用knn算法分类）、Drebin（提取权限、API、字符串等文本特征，使用SVM算法分类）和MaMaDroid（使用隐马可夫模型对API包名的调用关系进行建模，然后分类）等模型都是属于这一类。对抗方式也很简单，左边是针对API序列（N-gram）的，在API序列中插入良性的API，右边是针对MaMaDroid的，修改部分API的类型。 针对N-gram算法 针对MaMaDroid模型 &emsp;&emsp;经过前面的对抗方法的生成后，检测效果如下图。对于大量无用API的插入，逃逸率大约是80%（针对API的N-gram），混淆family/package名字的逃逸率是95%（针对MaMaDroid的特征）。 基于数据流&emsp;&emsp;模型如DroidMiner（提取应用程序组件之间和API之间的调用流图作为特征进行分类）、DroidSIFT（提取API调用关系，及其上下文关系作为特征进行分类）和FlowDroid（一个静态污点跟踪框架，对android应用程序的整个生命周期进行了模拟）等都属于基于数据流算法的模型，其中FlowDroid更加精确的提取API之间的数据流。一个数据流分析的例子： &emsp;&emsp;Source是指数据来源的可疑API（读），sink是指数据被传输的可疑API（写），当检测到source和sink有一条数据连通，就认为这是个敏感的数据流操作，并提示警告。例如上图的例子就是读取了短信（source），接着短信被http协议传输（sink）。针对数据流的攻击也是有2种，如下图： 方法1 方法2 &emsp;&emsp;第一种是增加对抗数据流分析的代码，让数据流分析的模型分析失败，不过这个块比较难对抗，从后面的测试结果也可以看得出。第二种是使用反射的机制调用敏感的API（反射是Java的一个属性，可以通过字符串调用类和函数，而字符串又可以加密），这种方法能够有效的逃逸数据流的跟踪。从下图的实验结果可以看出，输入对抗数据流分析的代码的逃逸率仅有34%，通过反射机制隐藏API名字的逃逸方法能够100%逃逸掉基于数据流的检测模型。 基于组件&emsp;&emsp;ASTROID是一个基于组件检测android恶意软件的的系统，其通过自动提取app组件之间的调用流图，然后提取同一家族最大相似子图作为该家族的签名特征，进而识别到该家族的其他样本。AVPASS针对该模型的逃逸也是很简单，在2个组件的调用流中插入其他无关组件，混淆恶意样本的组件调用流图。如一开始短信拦截木马的例子，在一次短信拦截的过程中，Revicer组件会调用Servie组件。而逃逸的过程只需要在组件调用流中，插入一个新的组件，就可以达到100%的逃逸。如下图： 混淆前 混淆后 基于签名&emsp;&emsp;基于签名其实比较简单，比如恶意软件的类名、函数名、访问的url、恶意字符串等等信息都可以拿来作为签名特征，前面提到的混淆手段都能够适用于基于签名的检测引擎的逃逸。 VT上AVs的逃逸（工业界）：&emsp;&emsp;上面提到的4种分类的测试用例都是拿学术界中开源模型进行测试的，接着作者对VirusTotal上面的反病毒引擎（AVs）进行了测试，在实验前提出了4个问题： 哪些特征是重要的？ 混淆哪些特征能影响检测结果？ AV引擎都使用了哪些分类器？ 它们对变种的样本是否具有足够的鲁棒性？ &emsp;&emsp;AVPASS的测试步骤也分成4步： 每个特征单独混淆然后查询，用来推断每个特征的影响程度 生成所有可能的变种然后查询，用来推断AVs检测样本特征的规则 将相似或者相关的特征混淆分组，用于降低查询的次数 为了安全的查询（不让AVs厂家获得完整的样本，但是又要体现混淆是否有效），使用假冒的恶意样本 &emsp;&emsp;从推断测试的结果中可以发现，其中5个特征是敏感的（strong），3个特征是普通的（normal），2个是弱的（weak），还有2个特征混淆对于检测结果没有影响。 &emsp;&emsp;（看到这里，我们可能会有一个疑问，为什么要推断出反病毒厂家使用的特征规则？而不是将所有能够使用的混淆技术都用上呢？原因有2个:1)为了最小化混淆特征能够通过检测。首先混淆程度太深，有可能会造成apk运行失败；其次，混淆程度有可能被拿来作为检测特征使用。2)对主要的特征进行混淆来生成伪装的恶意样本。意思就是对恶意特征进行混淆，留下良性的特征，而不是一股脑的全部混淆。） &emsp;&emsp;为了更简洁的测试，作者将混淆的特征分成7组，对100个样本不同组合的特征进行混淆，并提交到VT上进行检测（共进行了25,600次的查询）： &emsp;&emsp;最后得出结论： 大多数AVs厂商使用7种组合的规则来检测恶意样本 推断出来的组合特征大约占所有组合的30% 越好的AVs厂商使用越多的组合规则 &emsp;&emsp;查询过程还有一个问题需要解决：查询时如果使用全文件上传的话，这些样本都会被AVs厂商拿到，也就意味着这批样本很快就会失效，那么如何不让AVs厂商获得完整的样本，又能体现出混淆结果是否有效呢？作者提出了模仿模型(Imitation Mode)：将混淆后的恶意代码插入到良性样本中进行查询，如果该样本被查杀了，也就是混淆不成功，否则反之。 &emsp;&emsp;评估的结果如下，在不使用AVPASS工具下，2000个样本的检出率大约是65%，使用AVPASS后检出率是5.8%，基本上成功逃逸了各AV厂家的检测引擎。 &emsp;&emsp;对于全混淆和推断规则后再混淆2种情况，发现检出率差异不大，推断规则的效果稍差，原因是只混淆了30%的特征，但是同时兼容性和运行性能都更好。而模仿模式下的混淆会比全混淆要好。 &emsp;&emsp;对于为什么逃逸率不是100%，作者也做了2点的描述： 混淆不能修改所有的内容，比如权限（硬件请求和应用权限等）和Intent-filter（action、data）等 AVPASS有可能遗漏了厂商使用的其他特征 &emsp;&emsp;最后做了小结： 在VT上面的AVs都是基于静态分析的引擎，没有使用动态分析相关技术（VT本身有限制每个引擎的检查时间不能超过太长）。 AVs主要是还是使用模式匹配的方法，缺少一些更先进的技术，比如数据流、组件流等（但是这些技术也更加耗时） 50%的AVs只使用样本的hash作为检查特征。（修改样本1个字节就检测不了） 讨论：&emsp;&emsp;首先，作者讨论了哪一类AVs更难被逃逸。第一，检查了更多特征和更多规则组合的引擎，能更好的发现恶意样本；其次是使用了数据流和组件流的引擎更难被逃逸，虽然AVPASS目前能够逃逸这2种方法实现的模型，但是使用的方法太明显了，很容易被针对，并且经过AVPASS混淆后的样本很难再重新开发，从而逃逸数据流和组件流的检测方法。 &emsp;&emsp;接着，作者讨论了市面上反混淆的工具能否还原AVPASS生成的对抗样本。市面上反混淆的技术有2种，基于动态分析和基于概率分析。作者用一款商业上主流的反混淆工具DeGuard进行了测试，发现它能恢复70%的类名，其他的混淆就无能为力了。（只是恢复了类名混淆方法的70%，其他混淆方法都不能恢复） &emsp;&emsp;然后，作者讨论了防御的措施。首先，作者认为VT中的引擎应该增加其他标签，对于一些无效的样本应该返回无效，而不是良性或者恶意，因为混淆以后的恶意样本可能无法运行，如果返回恶意，那么就证明恶意代码被检查出来并且混淆方法没有用，进而推断出AVs使用的检测规则。其次，作者认为增加检测特征的数量也是有效的，可以防止模型被推测。最后，VT可以通过用户行为来识别推测行为，并对其进行一定的惩罚，比如在同一时间大量提交相似的样本，就需要对用户做一些限制了。 &emsp;&emsp;最后，作者还讨论了AVPASS的局限性。1)如果恶意软件使用了payload的形式，比如apk被加固、恶意代码放到so文件中等情况，AVPASS是无法处理的。 2)AVPASS在开源后，部分特征可能被AVs用来作为检查恶意样本的恶意特征。 3)一些混淆手段对动态分析是无效的。 文末附上一张AVPASS的使用流程图 总结:&emsp;&emsp;AVPASS的分析结束，从文中可以看出，AVPASS主要针对的是反病毒引擎的静态分析，并且使用的是有针对性的混淆攻击方法，与神经网络的对抗性攻击关系不大，不过这也是可以理解的，因为目前深度学习运用在安全领域的还是比较少，大家主要采用的还是传统的机器学习（重点就是如何进行特征提取），那么自然而且对抗的方法也就在如何混淆特征这一问题上。 &emsp;&emsp;AVPASS逃逸了4种主流的机器学习检测恶意软件的方法，并且自动化推断出了业界反病毒引擎所使用的特征规则，使用AVPASS后的恶意软件的检测率从65%降低到5.8%。 &emsp;&emsp;AVPASS的有效性告诫我们不仅仅需要关注模型的识别率，还更需要关注模型的鲁棒性和安全性。未来，恶意软件的攻与防还会一直持续下去，作为安全研究员任重而道远。]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>android malware</tag>
        <tag>对抗样本</tag>
        <tag>逃逸</tag>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个Android短信拦截马样本的分析报告]]></title>
    <url>%2F2018%2F09%2F27%2F%E4%B8%80%E4%B8%AAAndroid%E7%9F%AD%E4%BF%A1%E6%8B%A6%E6%88%AA%E9%A9%AC%E6%A0%B7%E6%9C%AC%E7%9A%84%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;近期有个朋友发来了一个针对俄罗斯的android恶意样本，该恶意apk伪装成一个照片应用，诱导用户点击下载并安装。本文对该恶意apk进行详细的分析。（说实话，这个木马跟我15年分析的第一个短信拦截马的功能差不多，发出来原因有3点：1)样本新且服务器还存活，本报告解密了远控端指令下发的相关流量。2)报告最后尝试利用威胁情报来分析这个黑客组织。3)为后续的文章做铺垫。） 木马简介&emsp;&emsp;木马是典型的android短信拦木马，为了逃逸杀毒引擎的静态扫描，该apk集成了一个内存泄露检测工具LeakCanary来增加良性行为，这个工具在github开源，被广大android开发者所使用，项目的star数达到了2w+。 基本信息 名称：Фoто 包名：com.tie.roar 入口：com.tie.roar.ConventionCommitment 版本信息：Ver：2.102.245(1) SDK：16 TargetSDK：25 MD5: f47d664bba5d751ad4390d75f4f19b0f SHA-1: ec1b835728eb538e272c9c6f8f7c02dcb41c53da 详细行为分析清单信息&emsp;&emsp;从下图可以看到，木马由多个组件组成，各组件负责不同功能，应用权限也声明了几个比较敏感的短信相关的权限。 隐藏自身&emsp;&emsp;木马安装运行后，会隐藏自身的图标，降低自身被发现的概率，达到常驻系统的目的。 &emsp;&emsp;下图是变化过程： 字符串解密 &emsp;&emsp;通过手动分析，发现木马对关键的字符串进行了加密，分析算法，得知是使用了自定义的异或算法加上base64编码： &emsp;&emsp;解密后的字符串： 1234567891011121314a=”android.settings.ACCESSIBILITY_SETTINGS”b=”Для уcтрaннения проблемы Вам нeобходимo включить 'Системноe прилoжениe' 1.Для этогo перейдите нa страницу нaстрoек 2.Выбeрите из cпискa 'Системноe прилoжениe' 3.Включитe егo.”c=”Систeмнaя непoладка”d=”Системноe прилoжениe”g=”http://whyadvhot.com/eqv2pvqgumbobw8n/index.php”h=”command”i=”model”j=”timestamp”k=”ver”l=”waitrun”m=”android.provider.Telephony.SMS_RECEIVED” &emsp;&emsp;变量b是一段俄语，通过google翻译可以知道该段文字是用来诱惑用户给木马打开辅助系统的权限，木马利用辅助系统可以做很多事情，比如模拟物理按键、模拟点击（自动安装应用）、息屏、亮屏幕等操作。 &emsp;&emsp;变量g是木马上线访问的url，通过这个url可以关联分析出这个黑客或者组织在过去10年的一些活动，后面进行分析。 木马上线&emsp;&emsp;木马使用Http进行上线通知，并使用Http协议传输命令进行操控客户端。 &emsp;&emsp;截获的数据包： &emsp;&emsp;解密后： 12&#123;"type":1,"data":&#123;"model":"Android SDK built for x86","ver":"6.3.4","android":"4.1.2","cell":"Android","x":260&#125;,"id":"d3b71c99311712cb"&#125; 指令下达&emsp;&emsp;木马通过回传指令让受控端进行一些敏感的操作，比如拨打电话、定向发送短信、劫持短信内容等。指令如下图所示： &emsp;&emsp;分析表明，7号指令是拨打电话、19号指令是劫持短信并且替换字符、11号指令是定向发送短信。这样的话，木马就能够通过后台扣费、获取银行验证码等手段来获利。部分解密流量如下： 12&#123;"command":0,"params":&#123;"timestamp":1537173808&#125;,"waitrun":0&#125;,&#123;"command":"11","params":&#123;"to":"+79173065404","body":"test number 2412403","timestamp":12281930,"x":0&#125;,"waitrun":1000&#125; 收集用户信息&emsp;&emsp;读取短信、联系人等信息。 监控短信&emsp;&emsp;木马会一直监控用户短信情况，当用户收到的短信时立马将短信内容通过url发送到服务器。下面是组包的代码： &emsp;&emsp;用模拟器测试一下收到短信的情况： &emsp;&emsp;短信发送后截获的木马上传数据到服务器的http包： &emsp;&emsp;解密数据如下： 1&#123;"type":2,"data":&#123;"n":"6505551212","t":"Hello, this is my password: 888888."&#125;,"id":"d3b71c99311712cb"&#125; 保活自身&emsp;&emsp;木马启动服务并使用onServiceConnected()函数来判断app是否在线。 &emsp;&emsp;当运行的服务发现app进程被杀掉的时候，马上启动app，并在前台伪装系统应用显示。 前台伪装&emsp;&emsp;木马伪装成系统应用在前台显示，避免后台运行被系统清理。 &emsp;&emsp;下面是显示的图片： 激活辅助功能&emsp;&emsp;当发现用户打开对木马不利的应用时，木马一直弹窗，逼迫用户跳转到开启辅助功能的界面。这样导致用户没法手动结束掉木马进程。 木马保护&emsp;&emsp;如果木马获得辅助功能，木马会通过模拟点击物理按键返回来阻止用户打开某些程序，这个程序黑名单由40号指令获取。阻止打开程序的相关代码： &emsp;&emsp;解密后的40号指令数据包如下： 12&#123;"command":40,"params":&#123;"text":"clean,.kms.,.drweb,.eset.,.ikarus.,.settings,:interactor,.gms.persistent,.packageinstaller,.cmcm,ahnlab,virus,avira,security,dianxinos,wsandroid,trendmicro,malware,tencent,sophos,mcafee,fsecure,sber,sber,com.android.mms","t":"android:id\/right_button,android:id\/button1,android:id\/restricted_action,android:id\/action_button,com.android.settings:id\/restricted_action,com.android.settings:id\/action_button,да,ок,подтвердить,разрешить,отправить,активировать","timestamp":1537173681,"x":1&#125;,"waitrun":0&#125; &emsp;&emsp;从数据包中可以看到mcafee、kms 、security、clean等一些安全厂商的包名字段，还有系统设置settings的字段。如果用户打开的应用名包含这些字段，木马将模拟物理返回按钮，导致用户打不开这些程序，也就无法手动杀掉木马进程了。 威胁情报分析&emsp;&emsp;木马访问的whyadvhot.com域名指向了IP为185.234.218.60的服务器，该IP在微步在线中被标记为恶意服务器，部分信息的信息如下： &emsp;&emsp;该IP地址在上半年的2018年3月份还发起了一起恶意邮箱攻击的事件。通过使用关联分析，可以发现该木马的作者是具有丰富的黑产经验，从下图可以看出，在服务器上面还存有大量的apk变种木马。 &emsp;&emsp;从数据中还可以查到，该黑客组织最早的活动可以追溯到2009年，一直进行着windows平台的木马传播，捕获的PE样本时间从2014年至2018年之间，说明该黑客组织一直保持着活跃，并从2018年9月开始传播大量的apk木马。从这次捕获到的木马也可以看出，该木马的功能比较局限，实现的手法也相对粗糙，在笔者分析的这段时间里，木马服务器还经常掉线，可能该木马还处于测试阶段，当然，对该组织的后续活动，我们也会一直跟踪下去。 总结&emsp;&emsp;这类木马主要是为了控制用户手机，通过拨打制定电话、发送指定短信，来到达恶意扣费的目的，进而谋取利益。当然，该木马还可以会监控用户短信，当用户正在进行短信验证，验证码将会发送到黑客服务器，进入导致用户账户或者银行财产等被盗。因此，在此建议用户一定不要随意点开的链接并按照应用。最好的方式是在设置中选择不允许从未知来源安装软件，从官方途径安装应用，这样就能避免被此类木马感染。]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>木马</tag>
        <tag>Android</tag>
        <tag>短信拦截</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[阅读笔记]《Automatic Problem Generation for Capture-the-Flag Competitions》]]></title>
    <url>%2F2018%2F09%2F05%2F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E3%80%8AAutomatic-Problem-Generation-for-Capture-the-Flag-Competitions%E3%80%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在过去一段时间里，笔者阅读了一些论文，也写了一些阅读笔记，最近想把笔记分享出来，与大家探讨，在鞭策中前行，希望能够坚持下去。原论文请戳这里 简介&emsp;&emsp;最近本人参加了国内最大型的线上CTF竞赛网鼎杯，这是本人第一次严格意义上的参加CTF竞赛，发现大佬云集，不过在队友的辅助下，本人成功解答了3道逆向题，整队分数也进入了前50名（其实是刚好第50名），当然也发现了国内CTF竞赛中共享flag是那么“流行 ”，接着就有了这篇阅读笔记。这是一篇在2015年发表于 USENIX’15(3GSE 15) 关于自动化生成CTF赛题的文章。CTF线上竞赛越来越流行，但是flag共享（py交易）也越来越多，文章主要介绍了自动化问题生成APG（automatic problem generation）技术，并且讨论了如何应用APG去检测flag共享（py交易）和该技术附带的其他好处和挑战，最后文章将APG技术应用于PicoCTF2014竞赛（一个面向高中和大学生的在线CTF竞赛，卡内基梅隆大学和世界顶级的CTF战队PPP共同举办，2014年参数人数超过10000人，一共3000+队伍），发现并捕获到多起flag共享事件，并对比赛数据进行了详细的分析。其中PicoCTF2014整个平台代码在github上开源。 中文摘要&emsp;&emsp;计算机安全游戏，尤其是夺旗赛（CTF）越来越流行。传统的CTF竞赛是指提供一组黑客挑战游戏给竞赛者，竞赛者在正确的解答题目后会得到一串文字叫做”flag”，提交给计分服务器将得到分数。在传统的CTF架构中，整个竞赛过程的题目和答案都是相同的。 &emsp;&emsp;在这篇文章中，我们讨论了自动问题生成（APG），一种给定的挑战但（题目和答案）不固定，相当于有很多不同的自动生成的题目实例。APG提供给玩家独特的竞赛体验，同时能够在问题的变化中促进有目的的练习，以确保用户可以复制解决方案的想法。APG也能够赋予管理者一种能力–检测用户是否提交了一个从其他队里py交易来的flag（a copied flag）到服务器。在2014年我们举办了一场大型的CTF竞赛叫做PicoCTF，在比赛中我们统计了flag共享的流行程度。我们的结果表明，提交AGP生成题目的flags，大约0.8%是py交易来的，同时14%的队伍至少提交了一个py交易来的flag。在flag共享事件中，68%的队伍最终自己也解决了题目（笔者注：先提交了py来的flag，然后又提交了自己的flag）。 介绍&emsp;&emsp;这一节详细介绍了CTF、APG、PicoCTF等概念，并且说明是如何应用APG技术到PicoCTF赛事中，最后说明了文章的贡献（其中结论比较有意思）： 文章详细描述了APG如何运用到PicoCTF赛事中，细节包括表现性能、可拓展性、题目难度的平衡、APG的选择等。 文章对PicoCTF2014共享flag的事件进行了统计分析，得出一些有意思的结论：不止低分段会py，高分段也存在py交易，并且共享flag的队伍很有可能来自同一学校。 PicoCTF平台在github上开源。 Automatic Problem Generation&emsp;&emsp;陈述陈述，然后举了一个凯撒密码的例子：服务器首先生成唯一的flag，然后附加到原始明文”the secret pass phrase is”后，接着服务器选取n（26个可能）做为密钥对明文进行加密得到密文，将结果派发给需要挑战的队伍（不同队伍会生成不会的flag和密钥）。这个例子是属于模板自动生成问题（ templated autogen problem），也就是一个模子里出来的题目（但是题目不完全相同，答案也不同），能够解决flag共享的作弊问题，但是不能解决解题思路共享的作弊问题，比如该例子虽然各队的flag不一样，但是解题思路都是凯撒密码。模板自动生成问题有2个作用：1)阻止和检测flag coping, 2)找出泄露flag的源。（这里应该很好理解，就是同一道题目，每个队伍的答案都是不一样的flag，这样当提交的是别队解答出来的flag当然就可以检测和阻止啦。泄露溯源的话就是如果同一时间大量的队伍提交同一flag，那么就可以找出这个flag对应的队伍，进而找出flag泄露的原因。文章在下一节举了个例子，当比赛进行到第5天时，突然有一个flag被大量提交，然后举办方发现原来是该flag所属的队伍在YouTube上把flag泄露了，如下图，橙色是不正确的提交，蓝色是正确的提交：） &emsp;&emsp;接着，文章提出了合成自动生成问题（ synthesized autogen problem），是指输入一系列约束条件的组合，然后自动生成题目。能够解决上面的2种作弊问题（共享flag和共享思路），但是生成的题目很难平衡难易，有失公平性。文章制定了一个通用的逆向工程挑战原型（用户必须提供满足不同复杂性约束的输入）、ROP攻击（不同的队伍需利用不同的gadgets和function）、以及隐藏在各种类型图像中的隐写问题。由于这些问题比较复杂，因此很难确保生成的不同实例具有相似的难度。出于这个原因，这些生成的题目没有在PicoCTF2014中使用。不过在未来中，这些题目可能有助于参赛者的练习，帮助其提高安全技能。 &emsp;&emsp;之后，文章讨论了CTF赛事中使用APG题目的一些挑战： 保持一致的难度。主要是说，自动生成的题目实例可能难度不一样，比如PicoCTF2014的一道XOR异或题，由于自动生成的题目是从0-255中取一个字节与明文进行异或加密，那么对于收到异或字节0题目的队伍，他们拿到的密文就是明文（就不用解密操作了，直接提取flag），造成各题难度不一致。 Bug的预防。APG可能产生非预期的bug，这会给比赛带来一些问题。举例了使用python函数strip()会造成非预期的错误，strip函数是取参数的每个单字节，并去除字符串头尾存在的相同字节。比如 strip(““)的本意是去除html标签，但是其实如果头尾存在t、d字符也会被去掉，而每个队伍拿到的flag都是随机生成并且唯一的，那么可能有些队伍的flag头尾存在t、d字符，被去掉后造成服务器判断flag无效。 可扩展性和部署。可扩展性是说可能有很多新的特性，平台需要比较容易扩展。部署是另一个新的挑战，因为每道题每个队伍的flag不同，那么flag的生成可能需要绑定队伍的token。 &emsp;&emsp;最后，文章介绍了APG应用于PicoCTF中，并介绍了部分代码的架构，比如一道APG题目，需要一个 generator和一个 grader，generator主要负责生成题目，grader主要负责判断队伍提交的答案是否正确。 Flag Sharing in PicoCTF 2014：&emsp;&emsp;接下来，作者统计了PicoCTF2014比赛中，flag sharing事件，并进一步对其详细的分析，还对flag泄露事件进行了溯源分析： &emsp;&emsp;文章表示，有71%的flag共享事件都是出现在同一个学校之间，并且不止低分段有flag共享，高分段也会出现flag共享事件。 讨论：&emsp;&emsp;作者发现，很多关于flag共享的因素都是PicoCTF唯一的，如： PicoCTF比赛持续了12天，使得flag不被泄露更具有挑战。 很多参赛队伍都是来自同一个学校，使得flag共享变动更加容易。 更多的参赛人员是新手玩家，相比有经验的人，可能更不清楚flag共享的严重性。 &emsp;&emsp;所以，作者认为造成PicoCTF中flag共享频繁出现并且覆盖面广的原因具有唯一性，其他类似的比赛可能很少出现，有也是集中于个别队伍。（本人不这么认为，你懂得） 结束语&emsp;&emsp;纵观国内的CTF比赛，好像还没有出现一个类似的防作弊技术运用于CTF中，基本都是同一道题同一flag。据我所知，这次网鼎杯比赛中使用了其他手段：1)通过检测pwn题目的流量，来检测是否有队伍进行了作弊，或者答案的泄露；2)同时使用了赛后复查wp的机制来防作弊（不过最后好像没有时间检查wp）。但是这2个方法都具有局限性，比如通过流量只能检测部分pwn的作弊，修改解题的脚本流量就能绕过检测；通过审核wp虽然可以一定程度防止作弊，但是需要大量的人力。攻防是一个持续不断的过程，如何更有效的防止线上CTF的作弊也是值得思考的事情。]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>notebook</tag>
        <tag>PicoCTF</tag>
        <tag>APG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析2018腾讯游戏安全竞赛题目（上）]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%89%96%E6%9E%902018%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E9%A2%98%E7%9B%AE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录 目录 前言 STL逆向分析 Base64逆向分析 AES算法逆向分析 注册机实现 前言&emsp;&emsp;这篇文章的内容详细的分析2018腾讯游戏安全竞赛的赛题，一开始本来只是想跟大家分享一下我是如何逆向分析STL代码的，后面突发奇想要不把整个比赛的题目分析完写出文章，经过三个月的拖延症，终于搞完了资格赛的题目，后面应该还有一篇关于决赛题的分析，所以暂且将这篇命名为（上）。 STL逆向分析&emsp;&emsp;前年腾讯游戏安全资格赛有STL，去年也是，今天还是，足以看出腾讯对STL的基础是多么看重（敲黑板，同学们，划重点了！腾讯面试也经常考STL的知识！）。今天就从STL入手，详细的讲讲竞赛中用到的STL相关知识。 &emsp;&emsp;STL是Standard Template Library的简称，中文名标准模板库，从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。（这一段摘自百度百科） &emsp;&emsp;这里只讲如何学习string和vector逆向相关的内容，其他“容器”的分析方法都是一样的。当然不同编译器的STL实现可能不一样，我这边选择vs2010来说明（vs的不同版本实现应该差不太多）。 STL分析&emsp;&emsp;首先，弄明白一个类的结构对逆向是非常重要的，所以我们从结构入手去学习。接着，我们看看常用的类函数被编译器编译的结果是怎么样的（对比有无调试符号2种情况）。最后，提取关键特征，方便以后使用。Let’s go! &emsp;&emsp;通过查看string.h的代码，找出string的结构，提取结构如下： 1234567891011121314151617struct __cppobj std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; : std::_String_val&lt;char,std::allocator&lt;char&gt; &gt;&#123;&#125;;struct __cppobj __declspec(align(4)) std::_String_val&lt;char,std::allocator&lt;char&gt; &gt; : std::_Container_base0&#123; std::_String_val&lt;char,std::allocator&lt;char&gt; &gt;::_Bxty _Bx; unsigned int _Mysize; unsigned int _Myres;&#125;;union std::_String_val&lt;char,std::allocator&lt;char&gt; &gt;::_Bxty&#123; char _Buf[16]; char *_Ptr; char _Alias[16];&#125;; // 这是一个union结构，3个变量共用16字节内存。 &emsp;&emsp;通过上面的继承关系，总结一下string的结构大体如下： 1234567struct string&#123; char _Buf[16]; // 当字符串长度小于等于0xF时，数据存储在_Buf数组中 // 大于0xF时将分配一个变量，_Buf存储的是该变量地址。 unsigned int _Mysize; // 字符串长度 unsigned int _Myres; // 可存储的最大长度&#125; &emsp;&emsp;知道了string结构，就知道string的大小，16+4+4 = 24个字节，我们用OD调试验证一下： 字符串长度为4的string内存分布 字符串长度为0x17的string内存分布 &emsp;&emsp;接着，我们编译一个程序（源码在文末附件中），打开其源码和2个IDA进行对比分析（IDA一个加载调试符号PDB，一个不加载调试符号）。先看main函数的前2句代码： 源码 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;再来看看后面2句被ida反编译后的结果： &emsp;&emsp;我们也可以跟进testString（sub_401080）函数去看看，为了篇幅原因，这里就不再细说了，大家有需要可以自己去对比分析一下。最后我们总结一下，根据ida的分析，我们知道string的初始化情况，大约有2种： 123456789101112131415// 第一种，v18是一个stringint v18; // [sp+2Ch] [bp-30h]@1int v19; // [sp+3Ch] [bp-20h]@1unsigned int v20; // [sp+40h] [bp-1Ch]@1v20 = 0xF;v19 = 0;LOBYTE(v18) = 0;// --------------------------------------// 第二种，a1是一个string*(_DWORD *)(a1 + 0x14) = 0xF;*(_DWORD *)(a1 + 0x10) = 0;*(_BYTE *)a1 = 0; &emsp;&emsp;这就是string的初始化结构，其实这两种本质上是一样的，一个局部变量，一个是参数变量。当遇到这两种结构，那么很大可能就是一个sting变量。还有一点需要提一下，就是string有2种存储结构，所以每次取string里的字符串时，都需要判断一下最大长度 _Myres 是否大于0x10，这个也是很经典的一个特征，如下： 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;其他string相关的函数大家可以直接去跟一下，反正就那么几个，这里直接给出一些总结： 函数名 参数 特征 解析 string.erase this,off,count ● 存在字符串”invalid string position”● 调用_memmove()函数 - string._copy string,newsize,oldsize - - string.append a1,a2 ● 存在2个字符串”string too long”● 调用了_copy()函数 ● 如果_copy中的newsize = oldsize+1,则append相当于string+=char;● 如果_copy中的newsize = oldsize+size,则append相当于string+=string; string.asign str1,off,count,str2 ● 存在2个字符串”invalid string position”● 存在字符串”string too long● 调用2次erase(),1次_copy(),1次_memcpy() ● 用str2初始化str1● 相当于str1=str2; string._Grow str1,size,bool ● 存在字符串”string too long”● 调用1次_copy(),1次_memcpy() sting.operator+ str1,str2,str3 ● 调用1次_Grow()● 最后2次连续的append()和return ● append(str1,str2);● append(str1,str3);● return str1;● 相对于str1=str2+str3; string.substr off,count ● 初始化string并且调用asign() ● asign()函数有2个参数就是需要截断的位置和长度 &emsp;&emsp;接着看看vector容器，方法还是一样，先来看看代码里面的结构，提取如下： 1234567891011struct __cppobj std::vector&lt;char,std::allocator&lt;char&gt; &gt; : std::_Vector_val&lt;char,std::allocator&lt;char&gt; &gt;&#123;&#125;;struct __cppobj __declspec(align(4)) std::_Vector_val&lt;char,std::allocator&lt;char&gt; &gt; : std::_Container_base0&#123; char *_Myfirst; char *_Mylast; char *_Myend; std::allocator&lt;char&gt; _Alval;&#125;; &emsp;&emsp;这个就是vector的结构了，简化一下： 123456struct vector&#123; char *_Myfirst; // 指向第一个元素 char *_Mylast; // 指向最后一个元素 char *_Myend; // 指向预分配内存的最后一个位置&#125;; &emsp;&emsp;vector是一个数组，数组的元素 T 都是连续存储在一块内存空间中，其中_Myfirst 指针指向第一个元素，_Mylast 指向最后一个元素，那么很容易想到，数组元素的个数就等于 (_Mylast -_Myfirst) / sizeof(T) 。 &emsp;&emsp;接下来以vector、vector、vector、vector为例说明，先看2个例子： &emsp;&emsp;结构上跟源码基本无差，只是back()和pop_back()函数被优化了，再来看看vector类型，这次用了另一种方式初始化： 源码 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;这种初始化方式会使用到vector类型的一个函数_Construct()，内部调用了insert将连续的数组插入到vector中。testVec的源码如下： 123456789101112131415vector&lt;int&gt; testVec(vector&lt;int&gt; &amp;vecInt)&#123; vector&lt;int&gt; vecRet; for (vector&lt;int&gt;::iterator it=vecInt.begin();it!=vecInt.end();it++) &#123; vecRet.push_back((*it)*999); &#125; for (int i=0;i&lt;vecInt.size();i++) &#123; vecRet.push_back(vecInt.back()); vecInt.pop_back(); &#125; return vecRet;&#125; &emsp;&emsp;如果IDA跟进到testVec函数里，会发现跟源代码差距非常大，原因是testVec函数里面的所有跟vector相关的函数(如begin()、push_back()、back() 等)都被优化了（库函数代码跟用户代码优化在一起了），不过细心去分析，会发现大部分代码都是在判断vector的空间是否需要重新分配，如果需要则调用reserve()函数进行调整。 &emsp;&emsp;看一个动态调整大小的例子，并且看看动态调整大小的方法： &emsp;&emsp;从上面的分析可以看出，动态调整的规则是以每次增加一半来调整的，如果增加一半的大小会溢出，则每次只调整加1，这也是为何当存储量很大的时候，STL会非常慢。 &emsp;&emsp;最后是vector、vector这两种，本质上struct和class是一样的。分析表明，这两种类型被编译后基本上也是跟vector类似的，这里只说明一下，如何确定元素struct或者class的大小。有2种方法，1)是通过循环时查看对_Myfirst增加的大小，这个大小就是元素结构的大小，例如： 12345678v3 = vecFlag-&gt;_Myfirst;for ( i = (int)v3; v3 != vecFlag-&gt;_Mylast; i = (int)v3 )&#123;... v21 = i； v3 = v21 + 8;&#125;// 则8就是元素的大小 &emsp;&emsp;2)是找到_Uninit_copy()函数，里面包含了对整个结构的初始化，对逆向非常有帮助，例如AClass： 源码 不带调试符号的IDA F5 带调试符号的IDA F5 &emsp;&emsp;从上图我们知道，这是一个类，类中有1个虚表，虚表里面有1个虚函数，类一共包括3个成员变量，类的大小一共 16 字节。 &emsp;&emsp;vector差不多就分析到这里，最后给出总结： 函数名 参数 特征 解析 vector.push_back a1 ● 存在2个字符串”vector too long” ● 特殊，会存在函数，不会被优化 vector.reserve vector1,size ● 存在字符串”vector too long”● 调用 new,allocate,memmove,delete 等函数 ● 如果size大于vector1的预分配内存空间的话，重新分配大小size vector.insert - ● 存在字符串”vector too long” ● 插入一个元素 vector._Construct - ● IDA F5后只有3行代码● 调用insert()函数 - vector.push_backvector.pop_backvector.back - ● 被优化在调用函数里面，没有独立的函数● 调用函数会判断vector大小并动态改变● 调用函数里面也会出现”vector too long”字符串 ● push_back(v1) –&gt; 取元素v1，判断vector的last是否等于end，是的话增加大小将v1赋值给last，last+=1(这里是指指向下一个元素，这里1要看vector里面元素的大小，如果是int，这里是4，如果是类，这里就是类的大小)● back() –&gt; 取last-1(就是指最后一个元素)● pop_back() –&gt; last-=1 算法逆向分析&emsp;&emsp;在开始分析题目前，我们回顾下上一节的内容，先来看看vector的结构是怎么样的，例子如下： 12string str[]=&#123;"1234","12345","123456","12345678901234567890"&#125;; vector&lt;string&gt; strArray(str, str+4); &emsp;&emsp;内存结构分析，如下： &emsp;&emsp;根据上一节的分析，string的大小是24字节，vector存储了4个string结构，系统预分配了2个结构。 &emsp;&emsp;开始分析程序，首先运行发现是mfc程序，使用xspy工具获取按钮事件的处理函数是sub_4026F0， 12xspy工具原贴：https://bbs.pediy.com/thread-170033.htm （感谢作者lynnux）xspy开源地址：https://github.com/lynnux/xspy 接着IDA分析： &emsp;&emsp;这里62-64行就是string初始化的经典结构，v14就是string类型，然后通过上下文可以知道，sub_402A70就是string.assign函数，赋值RegCode(v23)给v14。同样分析，v8也是string类型，保存了UserName。通过第80行的判断条件知道，sub_405510 函数返回1则显示成功，返回0则失败。接着我们来分析sub_405510 函数（这里我们需要记住传进去的参数），首先看看整体结构（只提取一些关键函数）： 1234567891011121314151617if ( sub_404F00() ) // 1&#123; sub_405040(); // 2 if ( sub_406080() &amp;&amp; ( a13 || sub_403010() )） // 3 &#123; v13 = sub_402F20(); // 4 &#125; else &#123; v13 = 0; &#125;&#125;else&#123; v13 = 0;&#125;return v13; &emsp;&emsp;v13是该函数的返回结果，必须返回1才能通过验证，也就是说第一个if判断中的sub_404F00()函数得返回真，之后执行sub_405040()函数。下一个if判断条件也得为真，即sub_406080()为真并且( a13 || sub_403010() )为真，这里a13是外部传进来标记是普通版还是进阶版的变量，当其为0时，sub_403010()函数得为真。最后执行sub_402F20()函数将结果赋值给v13。先看sub_404F00函数： &emsp;&emsp;一开始判断了字符串的长度是否等于39，接着31-35行的典型的取string类型中字符串(char*)的标准结构，同理36-39行、41-44行也是，后面还会出现这样的结构，就不再重复了。 &emsp;&emsp;这个循环是将所有的字符传递给sub_552E03函数，而该判断字符为小写字母时，将其转换为大写字母，函数内部主要的三行代码如下： &emsp;&emsp;接着往下看： &emsp;&emsp;这里出现了一个关键函数sub_404D70，然后进去分析，发现是split函数（本身STL是不包含这个函数），并且推断出v24是vector结构，数组元素个数是8。sub_404D70函数的分析如下： &emsp;&emsp;回到上一个函数继续分析最后一段： &emsp;&emsp;总结一下sub_404F00函数：函数的参数是UserName（string类型），函数判断了UserName的长度是否39，将存在的小写字母转化成大写字母，并通过调用split函数将其按照 “#” 符号进行分割，保存在vector结构中，分析得出是8个元素的数组，最后的判断限制了这些字符只能是 “0123456789ABCDEF” 这16个字符。通过以上分析，猜测UserName的格式是 “xxxx#xxxx#xxxx#xxxx#xxxx#xxxx#xxxx#xxxx”，x的范围为 “0123456789ABCDEFabcdef” 。 &emsp;&emsp;接着分析第2个函数，sub_405040函数，这个函数参数是上面转换成大写字母后的UserName，计算结果返回5个int64的值。这个函数很长很长，但是基本结构都是差不多的，这里只分析一小段： &emsp;&emsp;这里要说一下出现的偏移24、48，包括后面出现的72、96等，都是取vector数组元素的值，比如24*2=48，那么 v111[0]+48 就是取 vector[2] 的值。然后这里的主要计算是在135行和146行，细心提取就OK了。 编码实现&emsp;&emsp;最后使用c++将上节分析的2个函数的功能实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283vector&lt;string&gt; split(string str, string pattern)&#123; int pos; vector&lt;string&gt; result; str += pattern; int size = str.size(); for (int i = 0; i&lt;size; i++) &#123; pos = str.find(pattern, i); if (pos&lt;size) &#123; std::string s = str.substr(i, pos - i); result.push_back(s); i = pos + pattern.size() - 1; &#125; &#125; return result;&#125;bool CheckAndCalcUserName(string strUserName, _int64 &amp;nTmp1, _int64 &amp;nTmp2, _int64 &amp;nTmp3, _int64 &amp;nTmp4, _int64 &amp;nTmp5)&#123; // 将小写字母转化成大写字母 for(int i = 0;i&lt;strUserName.length();i++) if((unsigned int)(strUserName[i]-97)&lt;=0x19) strUserName[i] = strUserName[i] - 0x20; // 分割字符串，并判断元素个数 vector&lt;string&gt; vec_name = split(strUserName, "#"); if (vec_name.size() != 8) &#123; return false; &#125; // 判断所有字符是否在 "013456789ABCDEF" 这16个字符中 for(int i = 0;i&lt;vec_name.size();i++) &#123; string strTmp = vec_name[i]; for(int j=0;j&lt;strTmp.length();j++) &#123; char chTmp = strTmp[j]; if( (chTmp &gt; 57 || chTmp &lt; 48) &amp;&amp; (unsigned char)(chTmp - 65) &gt; 5 ) return false; &#125; &#125; // 开始计算 nTmp1 = (vec_name[0][0] * vec_name[1][0]) &lt;&lt; 16; nTmp1 += vec_name[0][1] ^ vec_name[2][1]; nTmp1 += (vec_name[0][2] % (vec_name[3][2] + 1)) + 1; nTmp1 += int(vec_name[0][2] / (vec_name[4][3] + 1)); nTmp2 = (vec_name[1][0] ^ vec_name[5][0]) &lt;&lt; 16; nTmp2 += vec_name[1][1] % (vec_name[6][1] + 3); nTmp2 += int(vec_name[1][2] / (vec_name[7][2] + 1)) + 5; nTmp2 += vec_name[1][3] + vec_name[0][3]; nTmp3 = int(vec_name[2][0] / (vec_name[1][0] + 3)) &lt;&lt; 16; nTmp3 ^= vec_name[2][1] % vec_name[3][1]; nTmp3 += vec_name[2][2] + vec_name[5][2] + 12; nTmp3 += vec_name[2][3] + vec_name[7][3]; nTmp4 = vec_name[0][1] ^ vec_name[2][3]; nTmp4 *= vec_name[1][3] + vec_name[3][1]; nTmp4 &amp;= vec_name[4][2] &amp; vec_name[5][2]; nTmp4 *= vec_name[7][3]; nTmp4 += nTmp2; nTmp4 *= vec_name[6][0]; nTmp4 *= nTmp1; _int64 t2 = nTmp4; t2 -= nTmp2; _int64 t = nTmp1 * 2; t = t2%t; nTmp4 -= t; nTmp5 = (vec_name[3][0] ^ vec_name[4][0]) &lt;&lt; 16; nTmp5 = nTmp5 * (vec_name[3][1] % (vec_name[4][1] + 2)); nTmp5 += (vec_name[3][2] % (vec_name[4][2] + 5)) + 7; nTmp5 += vec_name[3][3] * vec_name[4][3]; return true;&#125; Base64逆向分析&emsp;&emsp;Base64算法大家都用过，这个算法出现的主要的原因是解决有一些网络传输只支持可见字符的传输，而并不支持所有的字节的问题，base64算法能够将所有字节转换成可见字符。 Base64的编码与解码&emsp;&emsp;Base64的编码表如下：”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/“，一共64个字符，所以只需要6位就能表示，从0-63分别对应一个字符。一般比赛中Base64算法都会修改这个编码表（有些还会修改算法），从而导致正常base64算法无法解码，加强难度。也有作者通过爆破的方式解码base64中的编码表，当然，修改了算法的话，就无法爆破了。 &emsp;&emsp;一个字节是8位，base64每6位编码一次，也就是说，3个字节被base64编码后刚好等于4个字符，这对于优化计算也是非常重要的。如果不够3个字节将进行补0操作，补0中的6个0用“=”表示，这也是为什么base64编码后的字符串往往会有那么1，2个等号结尾。解码就是讲上述步骤反过来，下面看一个例子： &emsp;&emsp;上面是使用base64对字符串“1034”的编码和解码过程，编码后的结果为“MTAzNA==”。前面说了，编码时后补的6个0编码为“=”字符，不是后补的0是下标0，编码为“A”字符，如上面的红框。主要的代码实现如下： 12345678910// 编码核心代码index[0] = str[0] &gt;&gt; 2;index[1] = ((str[0] &amp; 0x3) &lt;&lt; 4) + (str[1] &gt;&gt; 4);index[2] = ((str[1] &amp; 0xF) &lt;&lt; 4) + (str[2] &gt;&gt; 6);index[3] = str[2] &amp; 0x3F;// 解码核心代码str[0] = (index[0] &lt;&lt; 2) + (index[1] &gt;&gt; 4);str[1] = (index[1] &lt;&lt; 4) + (index[2] &gt;&gt; 2);str[2] = (index[2] &lt;&lt; 6) + index[3]; &emsp;&emsp;base64的算法就介绍到这里，接下来说说这次比赛中使用到的base64算法。 Base64逆向分析&emsp;&emsp;我们进入sub_406080进行分析，F5一下。首先看下函数头： 1char __fastcall sub_406080(const char *a1, int a2) &emsp;&emsp;从该函数的外部我们知道，a1为我们输入的key字符串，那第二个参数是什么呢？不难发现，利用上一节STL的内容，通过跟踪变量，我们发现它很有可能是一个vector类型的变量，其中T可能是char类型，这个vector变量保存了该函数的计算结果。 &emsp;&emsp;知道了参数的意义，我们从反编译的第一行开始看起，首先有4个xmmword_xxxxxx类型的赋值语句给变量v26-v29赋值，从ida对变量的注释开始，我们知道变量v26-v29是在栈的连续空间中，__int128是16个字节，4个变量共16*4 = 64个字节，双击查看任何一个xmmword_xxxxxx变量，可以发现如下的值( 这里xmmword_5AC470没有使用 )： &emsp;&emsp;也就是说，这64个字节都是可视字符，他们排序的结果如下“ZO6Kq79L&amp;CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#”。为什么这里要分4个值赋值呢？其实是为了防止一眼看出这个是在初始化编码表。从这里我们大约已经可以猜测，这可能是一个base64的算法，并且编码表被修改了。我们接着分析： &emsp;&emsp;这里46行判断了key的长度是否是4的倍数，如果不是则返回false，前面分析已经知道了，base64编码后的字符串必须是4的倍数。接着跳转到第120的else块，分析如下： &emsp;&emsp;通过逐步分析，我们知道这个else块主要是获取key中的每一个字符并判断是否在base64的编码表中，如果存在某一个字符不在编码表中则返回flase，如果所有字符都没有问题，则跳转到LABEL_13中继续执行。细心的朋友可能会发现，如果key最后存在字符“=”不就不满足上面的循环了吗？因为“=”不在编码表中啊。确实，我也纠结了一小会，但是我们仔细看看v26初始化的那一段，会发现存在一个v30的变量，这个变量在41行被赋值为0x3d，而0x3d恰好是字符“=”的ascii码。也就是时候，在栈空间中，编码表的最后一个字符是“=”，其长度变成65。（这里OD动态调试一下就明白了） &emsp;&emsp;ida中，鼠标点一下41行的0x3d，并按键盘的R健，可以将0x3d按字符格式显示为“=”: &emsp;&emsp;继续分析 LABEL_13开始的代码。我们发现，从LABEL_13开始跟着1个大循环，大循环里面跟着4个小循环，首先我们分析小循环的代码，分析知道，每一个小循环是计算key中某一个字符在编码表中的位置，然后再通过66行的转换得到一个值，注意了，在正常的base64算法中，这个值是下标值，但是这里的算法被修改过，得到的是 index^(index &gt;&gt;3)。其他3个小循环的结构基本一样，唯一要注意的是63行v10相关的值，其实4个小循环分别计算key中4个字符对应的值。 &emsp;&emsp;计算的4个值分别保存到v13、v15、v18、v24中，记住，虽然这4个变量是byte型（8位），但是他们的值都小于64（6位） &emsp;&emsp;我们前面分析到sub_405EB0函数是与vector相关的函数，结合上下文和参数（也可以结合OD，看vector数据的变化和数组大小的变换），我们可以确定该函数是puth_back函数（保存计算的v25值到v22中），并且v22属于vector类型。 &emsp;&emsp;接着我们再来看看v25的值是如何计算的，其实已经很明显了，就是base64的解码运算，通过对v13、v15、v18、v24的移位和组合，得到个3 v25的值（4字节变3字节）。 注： 上图IDA中备注的高、低位只取字节的后6位（小于64） &emsp;&emsp;最后，我们总结一下这个base64的解码函数： 编码表被修改过。 取字符在编码表的位置后，多计算了一步（ index^(index &gt;&gt;3) ）。 解码的算法没有变。 &emsp;&emsp;解码流程写出来了，那么相应的编码函数也很简单，就是逆向解码流程，注意流程的第2点，它的逆向操作也是一样的计算，比如：result = index^(index&gt;&gt;3)，那么 result^(result&gt;&gt;3) 也就等于index。 编码与解码&emsp;&emsp;用c++实现base64的编码和解密函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273string strTbl = "ZO6Kq79L&amp;CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#";string Base64_Encode(string str)&#123; unsigned char index[4]; string strRet = ""; int i = 0; for (i = 0; i&lt;str.length() / 3; i += 1) &#123; index[0] = (unsigned char)str[i * 3 + 0] &gt;&gt; 2; index[1] = ((unsigned char)(str[i * 3 + 0] &amp; 0x3) &lt;&lt; 4) + ((unsigned char)str[i * 3 + 1] &gt;&gt; 4); index[2] = ((unsigned char)(str[i * 3 + 1] &amp; 0xF) &lt;&lt; 2) + ((unsigned char)str[i * 3 + 2] &gt;&gt; 6); index[3] = (unsigned char)str[i * 3 + 2] &amp; 0x3F; for (int j = 0; j&lt;4; j += 1) strRet += strTbl[index[j] ^ (index[j] &gt;&gt; 3)]; &#125; int n = str.length() % 3; if (n &gt;0) &#123; str += '\x00'; index[0] = (unsigned char)str[i * 3 + 0] &gt;&gt; 2; index[1] = ((unsigned char)(str[i * 3 + 0] &amp; 0x3) &lt;&lt; 4) + ((unsigned char)str[i * 3 + 1] &gt;&gt; 4); strRet += strTbl[index[0] ^ (index[0] &gt;&gt; 3)]; strRet += strTbl[index[1] ^ (index[1] &gt;&gt; 3)]; if (n == 1) &#123; strRet += "=="; &#125; else if (n == 2) &#123; str += '\x00'; index[2] = ((unsigned char)(str[i * 3 + 1] &amp; 0xF) &lt;&lt; 2) + ((unsigned char)str[i * 3 + 2] &gt;&gt; 6); strRet += strTbl[index[2] ^ (index[2] &gt;&gt; 3)]; strRet += "="; &#125; &#125; return strRet;&#125;string Base64_Decode(string str)&#123; unsigned char index[4]; string strRet = ""; for (int a = 0; a&lt;str.length() / 4; a++) &#123; for (int i = 0; i&lt;4; i++) &#123; for (int j = 0; j&lt;strTbl.length(); j++) &#123; if (str[a * 4 + i] == strTbl[j]) &#123; index[i] = j ^ (j &gt;&gt; 3); &#125; &#125; &#125; strRet += (index[0] &lt;&lt; 2) + (index[1] &gt;&gt; 4); if (str[a * 4 + 2] == '=') break; strRet += (index[1] &lt;&lt; 4) + (index[2] &gt;&gt; 2); if (str[a * 4 + 3] == '=') break; strRet += (index[2] &lt;&lt; 6) + index[3]; &#125; return strRet;&#125; AES算法逆向AES加解密分析&emsp;&emsp;这一节的主要内容可以参考《深入浅出密码学：常用加密技术原理与应用》第4章内容，详细知识书上都有说，这里只是简单说一说整个加解密的流程： 图片来源：《深入浅出密码学：常用加密技术原理与应用》 &emsp;&emsp;从上图可以看出，AES加密涉及到4个层（解密就是逆向运算）： 密钥拓展层（变换）。注：AES有一个特征，字节代换层存在SBox（加密使用）和iSBox（解密使用）。 密钥加法层。 字节代换层。 扩展层：ShiftRows层 和 MixColumn层。 &emsp;&emsp;分组加密方式的工作模式也可以分为好几种，wiki上面分为6种，如下： &emsp;&emsp;ECB模式指每一组明文加密都是独立的，而其他模式的加密会依赖于前后块的密文。ECB模式也是属于最弱的模型，重放攻击就是其受到的攻击之一。因此ECB模型下，相同的明文块加密后的密文也是相同的。这次比赛使用的就是ECB模型，确认方法也很简单，我们输入相同的块看AES加密后的密文是否相同就能确认。 &emsp;&emsp;加密前的字节： &emsp;&emsp;加密后的字节： &emsp;&emsp;我们可以发现，在相同明文块下（2行刚好就是2块），加密的结果是一样的，那么就是ECB模式了。 AES逆向分析&emsp;&emsp;掌握以上知识，我们开始逆向分析这次的变种AES算法，这个变种函数很多流程都被修改，但是还是有一些AES的细节被保留（比如 SBox、RC数组、MixColumn矩阵等），当我们分析透彻的话，写出逆向算法还是不难的。 &emsp;&emsp;首先，先分sub_403010函数的参数，根据传入的参数，我们知道改函数的结构如下： 123456// 参数 a1 为a2的长度size// 参数 a2 为vector&lt;char&gt;类型// 参数 a3 为传入的字符串（后面分析知道是AES加密的key）// 参数 a4 未使用// 参数 a5 为 a2char __usercall sub_403010@&lt;al&gt;(signed int a1_size@&lt;edx&gt;, vertor&lt;char&gt; a2, char* a3_key, int a4_unknow, vertor&lt;char&gt; a5) &emsp;&emsp;接着开始分析第一段，密钥拓展层： &emsp;&emsp;第269行的dword_5ABB88变量，我们点击进去看一下: &emsp;&emsp;这里其实是密钥拓展层用到的一个变量轮系数RC，但是轮系数RC的值本应该是这样的： 1char *szRC = &#123;1,2,4,8,0x10,0x20,0x40,0x80,0x1B,0x36&#125;; &emsp;&emsp;也就是说，这里的轮系数是32位数组，其中每个元素的高8位保存着数值（方面AES的g()函数进行32位异或） ，但是该题用错了，拿32位跟一个byte相与，导致后面的299行的 v15&amp;*v232 运算常为0，我们后面分析。 &emsp;&emsp;270行至281行的内容是把密钥从16字节的byte型数组转换成4个4字节的int型数组，这个非常容易看出来。接着284行至307行是一个的循环，这个是密钥拓展层的主要逻辑，通过分析发现，该密钥拓展算法跟正常的密钥拓展算法只是g()函数的实现有差异，如下图： 原AES的密钥拓展流程 修改后的密钥拓展流程g()函数 图片来源：《深入浅出密码学：常用加密技术原理与应用》 &emsp;&emsp;从上图可以看出g()函数的不同之处，首先位移的位置不同，其次经过SBox转换后，修改版还多了跟原值异或这一步，最后再进行RC相关的操作。这里RC[i]是32位，并且高8位才有数值，其它位为0，与上一个8位的数值，结果常为0，任何数与0异或都是它本身，所以相当于没有与RC操作这一步了。 &emsp;&emsp;以上就是密钥拓展层，在解题的时候这一部分是不用分析的，直接从内存里抠出来利用就行，但是平时学习的话还是有必要分析一下。 &emsp;&emsp;生成完密钥后，接着是对待解密的数组进行一系列的操作。首先是对待解密的字节数组进行转换，单字节转换成DWORD并且进行转置操作（下图的314行至330行），然后与密钥组进行异或（332行至343行）： &emsp;&emsp;上图变量v257所指向的空间就是计算过程中保存的结果，后面很多层都可以通过动态调试对结果的分析看出来，而不用实际去分析代码。接着进行逆向的SBox变换（iSBox）： &emsp;&emsp;接着是逆向的shift_row层（步骤8），这里进行静态分析比较麻烦，直接动态跟踪输入输出的变化就能看出来： &emsp;&emsp;shift_row层过后是MixColumn层（步骤9），因为是解密函数，所以是逆向的MixColumn层： &emsp;&emsp;这层的识别非常容易，查看dword_5ABBB0变量，发现其实就是InvMixColumn层的一个矩阵： dword_5ABBB0变量空间 逆向的MixColumn层 MixColumn层 &emsp;&emsp;而这里的矩阵乘法非常不同，不是用的乘法实现，而是对每一个字节进行判断再进行对应的操作，用了一大串switch结构，这样的实现导致代码量比较大，不过多看几遍就懂了。 &emsp;&emsp;（后面的层跟前面的层代码结构类似，只要注意下输入输出就好，这里不再列举代码，有兴趣的同学可以分析分析idb ）接着再取倒数第二行的key，对key进行InvMixColumn层变换，再一次进行密钥加法层的运行。然后以上步骤从iSBox层开始循环9次。经过9次循环后，最后对结果再进行一次iSBox变换和ShiftRow层变换，并取第一行的key与结果相异或，得到的就是最终结果。 AES加密与解密&emsp;&emsp;上一节我们分析了解密函数，这一节我们需要还原加密函数，在这之前，我们再把解密流程梳理一下，整理成流程图： &emsp;&emsp;对比《深入浅出密码学：常用加密技术原理与应用》中AES算法的加密与解密流程图，我们发现这个解密函数左边的流程图跟AES的加密函数一样，而右边的密钥拓展流程图又跟解密函数的密钥流程图一样，这真是魔改版的AES啊。最后实现加密函数，我们只需要按照该解密函数反向操作就行了，这里不再说明，有兴趣的同学可以看附加中的代码，代码实现了该魔改版AES的加密和解密函数，编码过程还有一个需要注意的是，这里的SBox和iSbox都是经过变换的，跟原版的AES的Box不一样，需要从文件中dump出来。 注册机的实现&emsp;&emsp;前面的3节分析了整个题目的90%，我们还有最后一个函数sub_402F20，现在再来看看整个分析： &emsp;&emsp;进去看看sub_402F20长啥样子： &emsp;&emsp;上面的函数参数经过了重命名，参数是8个int64类型的值（T1-T5已知，求T6,T7,T8），按照参数压栈的方式顺序命名就好了。最后将代码整理成求解的方程，如下： 123_int64 nTmp6 = (nTmp4 - nTmp2) / (2 * nTmp1); _int64 nTmp7 = nTmp6*nTmp6*nTmp1 + nTmp6*nTmp2 + nTmp3; _int64 nTmp8 = nTmp3 + ((nTmp2 + (nTmp1*nTmp5) - nTmp4) * nTmp5); &emsp;&emsp;目前我们逆向完了整个校验的过程，接着考虑如何写注册机。在这之前，把整个校验过程总结如下： &emsp;&emsp;明白了整个校验过程，那么写注册机就比较简单，UserName 流程不变，RegCode通过倒推回去就能计算出来。首先，通过UserName计算出T1-T5，然后通过解方程计算出T6-T8，接着拼接T9（T9为字符串”2018\x00\x00\x00\x00”）输入到AES加密算法中，得到数据最后再进行一次Base64编码，最终的结果就是我们需要的RegCode。详情请看附件中的代码。 附件下载 (上篇完)]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>游戏安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018看雪·京东AI CTF大挑战特别题 writeup]]></title>
    <url>%2F2018%2F07%2F16%2F2018%E7%9C%8B%E9%9B%AA%C2%B7%E4%BA%AC%E4%B8%9CAI-CTF%E5%A4%A7%E6%8C%91%E6%88%98%E7%89%B9%E5%88%AB%E9%A2%98-writeup%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;非常荣幸，这次AI与CTF结合的比赛本人获得了第二名（估计很多大佬懒得做，都跑去打常规赛了）。这一篇文章是本人发在看雪的解题报告，现转载到个人博客。原地址 请点击这里 前言&emsp;&emsp;前不久自己也思考过能不能将热门的AI技术与CTF比赛结合起来，没想到就意外发现了这道题，感觉非常有趣。 题目解析&emsp;&emsp;首先，阅读题目，发现模型是使用深度学习来检测一段二进制代码中是否存在函数入口，存在的话将入口点标为1，否则为0。而题目需要我们对模型机进行微调，使得模型能够识别出一段不能识别的二进制代码的入口点。说白就是我们需要造一些样本，重新训练模型使得模型能够识别给定样本的函数入口点并保证不是入口点也能识别正确。题目提供了模型的文件和样本点2个数据。 &emsp;&emsp;接着，我们需要看看模型是使用什么框架生成的，查看模型文件的二进制代码，发现是hdf文件： &emsp;&emsp;使用python的h5py工具解析，发现模型是基于theano工具的keras框架生成的，使用的RNN算法： &emsp;&emsp;代码如下： 123456789101112131415161718192021222324252627282930313233import h5pydef print_dateset(name,d): if type(d).__name__ == "Group": print(" &#123;&#125;".format(name)) for name1, d1 in d.items(): print_dateset(name1,d1) else: print(" &#123;&#125;: &#123;&#125;".format(name, d.value.shape)) # 输出储存在Dataset中的层名称和权重 print(" &#123;&#125;: &#123;&#125;".format(name, d.value))def print_keras_wegiths(weight_file_path): f = h5py.File(weight_file_path) # 读取weights h5文件返回File类 try: if len(f.attrs.items()): print("&#123;&#125; contains: ".format(weight_file_path)) print("Root attributes:") for key, value in f.attrs.items(): print(" &#123;&#125;: &#123;&#125;".format(key, value)) # 输出储存在File类中的attrs信息，一般是各层的名称 for layer, g in f.items(): # 读取各层的名称以及包含层信息的Group类 print(" &#123;&#125;".format(layer)) print(" Attributes:") for key, value in g.attrs.items(): # 输出储存在Group类中的attrs信息，一般是各层的weights和bias及他们的名称 print(" &#123;&#125;: &#123;&#125;".format(key, value)) print(" Dataset:") for name, d in g.items(): # 读取各层储存具体信息的Dataset类 print_dateset(name,d) finally: f.close()print_keras_wegiths("gcc_O2.h5") &emsp;&emsp;之后使用keras自带的模型绘制接口，将模型结构图打印出来： &emsp;&emsp;代码如下： 12345from keras.models import load_modelfrom keras.utils import plot_modelmodel = load_model("gcc_O2.h5")plot_model(model, to_file='model.png',show_shapes=True) &emsp;&emsp;知道了模型使用的框架，那么之后重新训练模型就非常方便了，再来看看样本点。观察发现，一段正常二进制代码应该会存在很多个0，而样本点存在很多个1且没有0，同时单字节存在几个256（单字节最大应该只有255），所以这里的二进制代码是经过加1运算后的代码，我们通过减1再进行反汇编，看看函数的入口特征： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859600048E000 &gt; 31C0 xor eax,eax 0048E002 83FA 0F cmp edx,0xF0048E005 0f94c0 sete al0048E008 &gt; 8D04C5 08000000 lea eax,dword ptr ds:[eax*8+0x8]0048E00F C3 retn0048E010 &gt; 31C0 xor eax,eax 0048E012 83FA 0F cmp edx,0xF0048E015 0f94c0 sete al0048E018 &gt; 8D04C5 09000000 lea eax,dword ptr ds:[eax*8+0x9]0048E01F C3 retn0048E020 &gt; 90 nop0048E021 8DB426 00000000 lea esi,dword ptr ds:[esi]0048E028 &gt; 83EC 0C sub esp,0xC0048E02B 895C24 04 mov dword ptr ss:[esp+0x4],ebx0048E02F 31DB xor ebx,ebx0048E031 897424 08 mov dword ptr ss:[esp+0x8],esi0048E035 89C6 mov esi,eax 0048E037 0FB6041E movzx eax,byte ptr ds:[esi+ebx]0048E03B E8 18FFFFFF call 0048DF580048E040 &gt; 83F8 14 cmp eax,0x140048E043 76 0B jbe 0048E0500048E045 E8 7E3AFFFF call 00481AC80048E04A 8DB6 00000000 lea esi,dword ptr ds:[esi]0048E050 &gt; FF2485 A8910F08 jmp dword ptr ds:[eax*4+0x80F91A8]0048E057 90 nop0048E058 &gt; B8 03000000 mov eax,0x30048E05D 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E061 01D8 add eax,ebx0048E063 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E067 83C4 0C add esp,0xC0048E06A C3 retn0048E06B 90 nop0048E06C &gt; 8D7426 00 lea esi,dword ptr ds:[esi]0048E070 &gt; B8 02000000 mov eax,0x20048E075 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E079 01D8 add eax,ebx0048E07B 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E07F 83C4 0C add esp,0xC0048E082 C3 retn0048E083 90 nop0048E084 &gt; 8D7426 00 lea esi,dword ptr ds:[esi]0048E088 &gt; 83C3 01 add ebx,0x10048E08B ^ EB AA jmp short idaq.0048E0370048E08D 8D76 00 lea esi,dword ptr ds:[esi]0048E090 &gt; B8 01000000 mov eax,0x10048E095 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E099 01D8 add eax,ebx0048E09B 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E09F 83C4 0C add esp,0xC0048E0A2 C3 retn0048E0A3 90 nop0048E0A4 &gt; 8D7426 00 lea esi,dword ptr ds:[esi]0048E0A8 &gt; B8 05000000 mov eax,0x50048E0AD 8B7424 08 mov esi,dword ptr ss:[esp+0x8]0048E0B1 01D8 add eax,ebx0048E0B3 8B5C24 04 mov ebx,dword ptr ss:[esp+0x4]0048E0B7 83C4 0C add esp,0xC0048E0BA C3 retn0048E0BB 8DB6 00000000 lea esi,dword ptr ds:[esi]0048E0C1 8DBC27 00000000 lea edi,dword ptr ds:[edi] &emsp;&emsp;题目提示说这一段代码的函数入口点是在下标为40的点，也就是上面所示的 0048E028 地址的 sub esp,0xC 这一句函数的入口点 模型无法识别，这个函数反编译后的结果其实是一个switch结构，类似如下： 123456789101112131415void test(int arg1)&#123; int a1,a2,a3; ... switch(arg1) &#123; case : break; case : break; case : break; ... &#125;&#125; &emsp;&emsp;题目解析到这里，接下来说说如何解答。 解题方法&emsp;&emsp;首先，我们把样本点输入到模型中，看模型预测的结果，发现每个点输出一个包含2个元素的向量，第1个表示不是入口点的概率，第2个表示是入口点的概率。从输出的结果可以看出，除去第40个点的概率是 [0.722，0.278]，其他基本都是 [1,0]，说明模型差一点就能识别出函数的入口点，而其它的点也没有识别错误。 &emsp;&emsp;模型预测的结果： 12345678910111213[[[ 1.00000000e+00 1.01599495e-09] [ 1.00000000e+00 9.24199650e-09]... [ 1.00000000e+00 2.13964561e-13] [ 1.00000000e+00 8.94351252e-17] [ 1.00000000e+00 1.66032972e-13] [ 7.22238600e-01 2.77761400e-01] # 这个是原始的模型对下标为40的预测结�? [ 1.00000000e+00 1.01078647e-19] [ 1.00000000e+00 4.74433075e-21] [ 1.00000000e+00 1.37062649e-18] [ 1.00000000e+00 1.50506920e-25]... [ 1.00000000e+00 2.42857068e-14]]] &emsp;&emsp;那么，最简单的办法就是将样本点随便改改，然后输入到模型重新训练，应该就能识别。（这里题目没有要求模型需要保证在原始的样本中保持某一个准确度） &emsp;&emsp;我这里将样本点的第0个点 50 改成 49，也就是将第一句的 xor eax,eax 改成 xor al,al ，作为模型的一个训练样本，使用SGD作为优化方法，参数学习率 lr=0.0001, 动量momentum=0.9，使用的迭代次数为10次，并且冻结除RNN的其他层，再重新训练，结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243Epoch 1/101/1 [==============================] - 0s 12ms/step - loss: 0.0064 - acc: 0.9950Epoch 2/101/1 [==============================] - 0s 13ms/step - loss: 0.0063 - acc: 0.9950Epoch 3/101/1 [==============================] - 0s 13ms/step - loss: 0.0060 - acc: 0.9950Epoch 4/101/1 [==============================] - 0s 12ms/step - loss: 0.0057 - acc: 0.9950Epoch 5/101/1 [==============================] - 0s 12ms/step - loss: 0.0053 - acc: 0.9950Epoch 6/101/1 [==============================] - 0s 12ms/step - loss: 0.0048 - acc: 0.9950Epoch 7/101/1 [==============================] - 0s 12ms/step - loss: 0.0044 - acc: 0.9950Epoch 8/101/1 [==============================] - 0s 12ms/step - loss: 0.0039 - acc: 0.9950Epoch 9/101/1 [==============================] - 0s 12ms/step - loss: 0.0035 - acc: 1.0000Epoch 10/101/1 [==============================] - 0s 11ms/step - loss: 0.0031 - acc: 1.0000[[[ 1. 0.] [ 1. 0.]... [ 1. 0.] [ 1. 0.] [ 1. 0.] [ 0. 1.] # 这个是重新训练的模型对下标为40的预测结果 [ 1. 0.] [ 1. 0.] [ 1. 0.] [ 1. 0.]... [ 1. 0.]]] &emsp;&emsp;代码如下： 123456789101112131415161718192021222324252627from keras.optimizers import SGDfrom keras.models import load_modelimport numpy as npdef setup_to_finetune(model): for layer in model.layers: layer.trainable = False model.layers[1].trainable = True # RNN层 不冻结 model.compile(optimizer=SGD(lr=0.0001, momentum=0.9), loss='categorical_crossentropy', metrics=['accuracy'])a = [49,193,132,251,16,16,149,193,142,5,198,9,1,1,1,196,50,193,132,251,16,16,149,193,142,5,198,10,1,1,1,196,145,142,181,39,1,1,1,1,132,237,13,138,93,37,5,50,220,138,117,37,9,138,199,16,183,5,31,233,25,256,256,256,132,249,21,119,12,233,127,59,256,256,142,183,1,1,1,1,256,37,134,169,146,16,9,145,185,4,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,3,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,132,196,2,236,171,142,119,1,185,2,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,6,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,142,183,1,1,1,1,142,189,40,1,1,1,1]x_train = np.array([a])b = [[1,0] for i in range(200)]b[40] = [0,1] # 设置第40位为函数入口点y_train = np.array([b])model = load_model("gcc_O2.h5")setup_to_finetune(model)model.fit(x_train,y_train,batch_size=1,epochs=10) # 重新训练a = [50,193,132,251,16,16,149,193,142,5,198,9,1,1,1,196,50,193,132,251,16,16,149,193,142,5,198,10,1,1,1,196,145,142,181,39,1,1,1,1,132,237,13,138,93,37,5,50,220,138,117,37,9,138,199,16,183,5,31,233,25,256,256,256,132,249,21,119,12,233,127,59,256,256,142,183,1,1,1,1,256,37,134,169,146,16,9,145,185,4,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,3,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,132,196,2,236,171,142,119,1,185,2,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,145,142,117,39,1,185,6,1,1,1,140,117,37,9,2,217,140,93,37,5,132,197,13,196,142,183,1,1,1,1,142,189,40,1,1,1,1]x_test = np.array([a])print(np.rint(model.predict(x_test))) # 预测model.save("gcc_O2_new.h5") # 保存模型 结束语&emsp;&emsp;感觉这道题的逆向要求不是很高，然后深度学习算法的要求也不是很高，但是两者结合起来感觉挺有意思的。不过，没有其他限制的话，模型是可以过拟合的（只识别一个提供的样本点），为了避免模型过拟合，主办方其实可以提供一些样本，要求新的模型在这些样本下也能够保持准确度。 附件下载]]></content>
      <categories>
        <category>解题报告</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
        <tag>AI</tag>
        <tag>看雪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦幻手游部分Luac反编译失败的解决方法]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%A2%A6%E5%B9%BB%E6%89%8B%E6%B8%B8%E9%83%A8%E5%88%86Luac%E5%8F%8D%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这一篇是去年学习破解梦幻西游手游lua代码时记录的一些问题，今天将其整理并共享出来，所以不一定适合现在版本的梦幻手游，大家还是以参考为目的呗。lua相关的文章（共4篇）到此也写完了，如果以后还有新的东西会继续更新，接下来会写几篇关于2018 腾讯游戏安全竞赛的详细分析，敬请期待。 十二处bug修复&emsp;&emsp;当时反编译梦幻西游手游时遇到的问题大约有12个，修改完基本上可以完美复现lua源码，这里用的luadec5.1版本。 修复一&emsp;&emsp;问题1： 由于梦幻手游lua的opcode是被修改过的，之前的解决方案是找到梦幻的opcode，替换掉反编译工具的原opcode，并且修改opmode，再进行反编译。问题是部分测试的结果是可以的，但是当对整个手游的luac字节码反编译时，会出现各种错误，原因是luadec5.1 在很多地方都默认了opcode的顺序，并进行了特殊处理，所以需要找到这些特殊处理的地方一一修改。不过这样很麻烦，从而想到另外一种方式，不修改原来的opcode和opmode，而是在luadec解析到字节码的时候，将opcode还原成原来的opcode。 &emsp;&emsp;解决1： 定位到解析code的位置在 lundump.c –&gt; LoadFunction –&gt; LoadCode （位置不唯一，可以看上一篇腾讯比赛的修复），当执行完LoadCode函数的时候，f变量则指向了code的结构，在这之后执行自己写的函数ConvertCode函数，如下： 123456789101112// add by littleNAvoid ConvertCode(Proto *f)&#123; int pnOpTbl[] = &#123; 3,13,18,36,27,10,20,25,34,2,32,15,30,16,31,9,26,24,29,1,6,28,4,17,33,0,7,11,5,14,8,19,35,12,21,22,23,37 &#125;; for (int pc = 0; pc &lt; f-&gt;sizecode; pc++) &#123; Instruction i = f-&gt;code[pc]; OpCode o = GET_OPCODE(i); SET_OPCODE(i, pnOpTbl[o]); f-&gt;code[pc] = i; &#125;&#125; 修复二&emsp;&emsp;问题2： 在文件头部 反编译出现错误 – DECOMPILER ERROR: Overwrote pending register. &emsp;&emsp;解决2： 分析发现，原来是解析OP_VARARG错误导致的。OP_VARARG主要的作用是复制B-1个参数到A寄存器中，而反编译工具复制了B个参数，多了一个。修改后的代码如下：12345678910111213141516171819... case OP_VARARG: // Lua5.1 specific. &#123; int i; /* * Read ... into register. */ if (b==0) &#123; TRY(Assign(F, REGISTER(a), "...", a, 0, 1)); &#125; else &#123; // add by littleNA // for(i = 0;i&lt;b;i++) &#123; for(i = 0; i &lt; b-1; i++) &#123; TRY(Assign(F, REGISTER(a+i), "...", a+i, 0, 1)); &#125; &#125; break; &#125;... 修复三&emsp;&emsp;问题3： 在解析table出现反编译错误 – DECOMPILER ERROR: Confused about usage of 。registers! &emsp;&emsp;解决3： 分析发现，这里的OP_NEWTABLE 的c参数表示hash table中key的大小，而反编译代码中将c参数进行了错误转换，导致解析错误，修改代码如下： 123// add by littleNA//#define fb2int(x) (((x) &amp; 7) &lt;&lt; ((x) &gt;&gt; 3))#define fb2int(x) ((((x) &amp; 7)^8) &gt;&gt; (((x) &gt;&gt; 3)-1)) 修复四&emsp;&emsp;问题4： 反编译工具出错并且退出。 &emsp;&emsp;解决4： 跟踪发现是在AddToTable函数中，当keyed为0时会调用PrintTable，而PrintTable释放了table，下次再调用table时内存访问失败，修改代码如下： 12345678910111213141516171819202122232425void AddToTable(Function* F, DecTable * tbl, char *value, char *key)&#123; DecTableItem *item; List *type; int index; if (key == NULL) &#123; type = &amp;(tbl-&gt;numeric); index = tbl-&gt;topNumeric; tbl-&gt;topNumeric++; &#125; else &#123; type = &amp;(tbl-&gt;keyed); tbl-&gt;used++; index = 0; &#125; item = NewTableItem(value, index, key); AddToList(type, (ListItem *) item); // FIXME: should work with arrays, too // add by littleNA // if(tbl-&gt;keyedSize == tbl-&gt;used &amp;&amp; tbl-&gt;arraySize == 0)&#123; if (tbl-&gt;keyedSize != 0 &amp;&amp; tbl-&gt;keyedSize == tbl-&gt;used &amp;&amp; tbl-&gt;arraySize == 0) &#123; PrintTable(F, tbl-&gt;reg, 0); if (error) return; &#125;&#125; 修复五&emsp;&emsp; 问题5： 当函数是多值返回结果并且赋值于多个变量时反编译错误，情况如下（lua反汇编）： 1234567821 [-]: GETGLOBAL R0 K9 ; R0 := memoryStatMap22 [-]: GETGLOBAL R1 K9 ; R1 := memoryStatMap23 [-]: GETGLOBAL R2 K2 ; R2 := preload24 [-]: GETTABLE R2 R2 K3 ; R2 := R2["utils"]25 [-]: GETTABLE R2 R2 K16 ; R2 := R2["getCocosStat"]26 [-]: CALL R2 1 3 ; R2,R3 := R2()27 [-]: SETTABLE R1 K15 R3 ; R1["cocosTextureBytes"] := R328 [-]: SETTABLE R0 K14 R2 ; R0["cocosTextureCnt"] := R2 &emsp;&emsp;当上面的代码解析到27行时，从寄存器去取R3时报错，原因是前面的call返回多值时，只是在F-&gt;Rcall中进行了标记，没有在寄存器中标记，编译的结果应该为： 1memoryStatMap.cocosTextureCnt, memoryStatMap.cocosTextureBytes = preload.utils.getCocosStat() &emsp;&emsp; 解决5： 当reg为空时并且Rcall不为空，增加一个return more的标记，修改2个函数： 12345678910111213141516171819202122char *RegisterOrConstant(Function * F, int r)&#123; if (IS_CONSTANT(r)) &#123; return DecompileConstant(F-&gt;f, r - 256); // TODO: Lua5.1 specific. Should change to MSR!!! &#125; else &#123; char *copy; char *reg = GetR(F, r); if (error) return NULL; // add by littleNA // if()&#123;&#125; if (reg == NULL &amp;&amp; F-&gt;Rcall[r] != 0) &#123; reg = "return more"; &#125; copy = malloc(strlen(reg) + 1); strcpy(copy, reg); return copy; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637void OutputAssignments(Function * F)&#123; int i, srcs, size; StringBuffer *vars; StringBuffer *exps; if (!SET_IS_EMPTY(F-&gt;tpend)) return; vars = StringBuffer_new(NULL); exps = StringBuffer_new(NULL); size = SET_CTR(F-&gt;vpend); srcs = 0; for (i = 0; i &lt; size; i++) &#123; int r = F-&gt;vpend-&gt;regs[i]; if (!(r == -1 || PENDING(r))) &#123; SET_ERROR(F,"Attempted to generate an assignment, but got confused about usage of registers"); return; &#125; if (i &gt; 0) StringBuffer_prepend(vars, ", "); StringBuffer_prepend(vars, F-&gt;vpend-&gt;dests[i]); if (F-&gt;vpend-&gt;srcs[i] &amp;&amp; (srcs &gt; 0 || (srcs == 0 &amp;&amp; strcmp(F-&gt;vpend-&gt;srcs[i], "nil") != 0) || i == size-1)) &#123; // add by littleNA // if() if (strcmp(F-&gt;vpend-&gt;srcs[i], "return more") != 0) &#123; if (srcs &gt; 0) StringBuffer_prepend(exps, ", "); StringBuffer_prepend(exps, F-&gt;vpend-&gt;srcs[i]); srcs++; &#125; &#125; &#125;...&#125; 修复六&emsp;&emsp;问题6： 当函数只有一个renturn的时候会反编译错误。 &emsp;&emsp;解决6： 123456789101112131415161718 case OP_RETURN:&#123; ... // add by littleNA // 新增的if if (pc != 0) &#123; for (i = a; i &lt; limit; i++) &#123; char* istr; if (i &gt; a) StringBuffer_add(str, ", "); istr = GetR(F, i); TRY(StringBuffer_add(str, istr)); &#125; TRY(AddStatement(F, str)); &#125; break; &#125; 修复七&emsp;&emsp;问题7： 部分table初始化会出错。 &emsp;&emsp;解决7： 12345678910char *GetR(Function * F, int r)&#123; if (IS_TABLE(r)) &#123; // add by littleNA return "&#123; &#125;"; // PrintTable(F, r, 0); // if (error) return NULL; &#125;...&#125; 修复八&emsp;&emsp;问题8： 可变参数部分解析出错，但是工具反编译时是不报错误的。 &emsp;&emsp;解决8： is_vararg为7时，F-&gt;freeLocal多加了一次： 12345678910if (f-&gt;is_vararg==7) &#123; TRY(DeclareVariable(F, "arg", F-&gt;freeLocal)); F-&gt;freeLocal++;&#125;// add by littleNA// 修改if为else ifelse if ((f-&gt;is_vararg&amp;2) &amp;&amp; (functionnum!=0)) &#123; F-&gt;freeLocal++;&#125; 修复九&emsp;&emsp;问题9： 反编译工具输出的中文为url类型的字符（类似 “\230\176\148\231\150\151\230\156\175”），不是中文。 &emsp;&emsp;解决9： 在proto.c文件中的DecompileString函数中，注释掉default 转换字符串的函数： 123456789101112131415char *DecompileString(const Proto * f, int n)&#123;... default: //add by littleNA// if (*s &lt; 32 || *s &gt; 127) &#123;// char* pos = &amp;(ret[p]);// sprintf(pos, "\\%d", *s);// p += strlen(pos);// &#125; else &#123; ret[p++] = *s;// &#125; break;...&#125; &emsp;&emsp;然后再下面3处增加判断的约束条件，因为中文字符的话，char字节是负数，这样isalpha和isalnum函数就会出错，所以增加约束条件，小于等于127： 12345678910111213141516171819202122232425262728293031323334353637383940void MakeIndex(Function * F, StringBuffer * str, char* rstr, int self)&#123;... int dot = 0; /* * see if index can be expressed without quotes */ if (rstr[0] == '\"') &#123; // add by littleNA // (unsigned char)(rstr[1]) &lt;= 127 &amp;&amp; if ((unsigned char)(rstr[1]) &lt;= 127 &amp;&amp; isalpha(rstr[1]) || rstr[1] == '_') &#123; char *at = rstr + 1; dot = 1; while (*at != '"') &#123; // add by littleNA // *(unsigned char*)at &lt;= 127 &amp;&amp; if (*(unsigned char*)at &lt;= 127 &amp;&amp; !isalnum(*at) &amp;&amp; *at != '_') &#123; dot = 0; break; &#125; at++; &#125; &#125; &#125;....&#125;... case OP_TAILCALL: &#123; // add by littleNA // (unsigned char)(*at) &lt;= 127 &amp;&amp; while (at &gt; astr &amp;&amp; ((unsigned char)(*at) &lt;= 127 &amp;&amp; isalpha(*at) || *at == '_')) &#123; at--; &#125; &#125;... 修复十&emsp;&emsp;问题10： 反汇编失败。因为一些文件中含有很长的字符串，导致sprintf函数调用失败。 &emsp;&emsp;解决10： 增加缓存的大小： 1234567void luaU_disassemble(const Proto* fwork, int dflag, int functions, char* name) &#123; ... // add by littleNA // char lend[MAXCONSTSIZE+128]; char lend[MAXCONSTSIZE+2048];...&#125; 修复十一&emsp;&emsp;问题11： op_setlist操作码当b==0时，反编译失败。 &emsp;&emsp;解决11： 当遇到类似下面的lua语句时，反编译工具会失败，出现的情况在@lib_ui.lua文件中： 1local a=&#123;func()&#125; &emsp;&emsp;汇编后的代码： 123456 a b c[1] newtable 0 0 0 ; array=0, hash=0[2] getglobal 1 0 ; func[3] call 1 1 0[4] setlist 0 0 1 ; index 1 to top[5] return 0 1 &emsp;&emsp;出现的问题有2处，第一个是newtable，当b == 0 &amp;&amp; c == 0时，反编译工具认为table是空的table，直接输出了table并且释放了table的内存，导致后面setlist初始化table时找不到内存而报错。 &emsp;&emsp;第二个是setlist有问题，当b==0时，其实是指寄存器a+1到栈顶（top）的值全部赋值于table，而反编译器没有对b==0的判断，加上就可以了。所以修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void StartTable(Function * F, int r, int b, int c)&#123; DecTable *tbl = NewTable(r, F, b, c); AddToList(&amp;(F-&gt;tables), (ListItem *) tbl); F-&gt;Rtabl[r] = 1; F-&gt;Rtabl[r] = 1; if (b == 0 &amp;&amp; c == 0) &#123; // add by littleNA // for()&#123;&#125; for (int npc = F-&gt;pc + 1; npc &lt; F-&gt;f-&gt;sizecode; npc++) &#123; Instruction i = F-&gt;f-&gt;code[npc]; OpCode o = GET_OPCODE(i); if ((o != OP_SETLIST &amp;&amp; o != OP_SETTABLE) &amp;&amp; r == GETARG_A(i)) &#123; PrintTable(F, r, 1); return; &#125; else if ((o == OP_SETLIST || o == OP_SETTABLE) &amp;&amp; r == GETARG_A(i)) &#123; return; &#125; &#125; PrintTable(F, r, 1); if (error) return; &#125;&#125;void SetList(Function * F, int a, int b, int c)&#123;... // add by littleNA // if()&#123;&#125; if (b == 0) &#123; Instruction i = F-&gt;f-&gt;code[F-&gt;pc-1]; OpCode o = GET_OPCODE(i); if (o == OP_CALL) &#123; int aa = GETARG_A(i); for (i = a + 1; i &lt; aa + 1; i++) &#123; char* rstr = GetR(F, i); if (error) return; AddToTable(F, tbl, rstr, NULL); if (error) return; &#125; &#125; else &#123; for (i = 1;;i++) &#123; char* rstr = GetR(F, a + i); if (rstr == NULL) return; AddToTable(F, tbl, rstr, NULL); if (error) return; &#125; &#125; &#125;...&#125; &emsp;&emsp;StartTable 增加的for循环表示，如果执行了newtable(r 0 0)，后面非初始化table的操作覆盖了r寄存器（把table覆盖了），那就表明new出来的table是空的，后面没有对table的赋值；如果后面有对r寄存器初始化，证明此时new出了的table不是空的，是可变参数的table。 &emsp;&emsp;SetList 增加的if表示，如果指令是call指令，那么将a+1到call指令寄存器aa的栈元素加入到table中（这里为何不是到栈顶的元素而是到aa的元素呢？因为call指令对应的是函数调用，反编译工具已经把函数调用的字符串解析到aa中了，这里跟实际运行可能有点不一样；else后面就是将a+1到栈顶的元素初始化到table中，直到GetR函数为空表示到栈顶了。 修复十二&emsp;&emsp;问题12： 当一个函数开头只是局部变量声明，如： 12345function func() local a,b,c c = f(a,b) return cend &emsp;&emsp;第一行 local a,b,c 会反编译失败，导致后面的代码出现各种错误。 &emsp;&emsp;解决12： 1234567891011121314151617181920void DeclareLocals(Function * F)&#123;... for (i = startparams; i &lt; F-&gt;f-&gt;sizelocvars; i++) &#123; if (F-&gt;f-&gt;locvars[i].startpc == F-&gt;pc) &#123; ... if (PENDING(r)) &#123;...&#125; // add by littleNA // else if()&#123;&#125; else if (locals == 0 &amp;&amp; F-&gt;pc == 0) &#123; StringBuffer_add(str, LOCAL(i)); char *szR = GetR(F, r); StringBuffer_add(rhs, szR==NULL?"nil":szR); &#125; ... &#125; &#125;...&#125; &emsp;&emsp;当变量的startpc 等于 当前pc，变量的个数为0并且当前pc为0，表示第一行声明了变量，添加的else if就是解析这种情况的（原来是直接报错不解析）。 &emsp;&emsp;（完）]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>手游安全</tag>
        <tag>luac反编译</tag>
        <tag>梦幻西游手游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密（后续）]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%EF%BC%88%E5%90%8E%E7%BB%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;趁着周末，把lua的后续文章也写完了。 反编译对抗&emsp;&emsp;众所周知，反汇编/反编译 工具在逆向人员工作中第一步被使用，其地位非常之高，而对于软件保护者来说，如何对抗 反汇编/反编译 就显得尤为重要。例如，动态调试中对OD的的检测、内核调试对windbg的破坏、加壳加花对IDA静态分析的阻碍、apktool的bug导致对修改后的apk反编译失败、修改PE头导致OD无法识别、修改 .Net dll中的区段导致ILspy工具失效等等例子，都说明对抗反编译工具是很常用的一种软件保护手段，当然lua的反编译工具也面临这个问题。处理这样的问题无非就几种思路： 用调试器调试反编译工具为何解析错误，排查原因。 用调试器调试原引擎是如何解析文件的。 用文件格式解析工具解析文件，看哪个点解析出错。 &emsp;&emsp;下面将以3个例子来实战lua反编译是如何对抗与修复。 例子1：一个简单的问题&emsp;&emsp;这是在看雪论坛看到的一个问题，问题是由于游戏（可能是征途手游）将lua字符串的长度int32修改为int64，导致反编译失败的一个例子，修复方法请看帖子中本人的回答，地址：https://bbs.pediy.com/thread-217033.htm 例子2：2018腾讯游戏安全竞赛&emsp;&emsp;这一节以2018腾讯游戏安全竞赛决赛第二题进阶版第1关的题目为例子，主要是讲一下如何修复当lua的opcode被修改的情况，以及如何修复该题对抗lua反编译的问题。 opcode问题及其修复&emsp;&emsp;修复opcode的目的是 当输入题目的luac文件，反汇编工具Chunkspy和反编译工具luadec能够输出正确的结果。 &emsp;&emsp;首先，我们在ida中分析lua引擎tmgs.dll文件，然后定位到luaV_execute函数（搜索字符串“ ‘for’ limit must be a number ”），发现switch下的case的参数（lua的opcode）是乱序的，到这里我们就能够确认，该题的lua虚拟机opcode被修改了。 &emsp;&emsp;接着，我们进行修复操作。一种很耗时的办法就是一个一个opcode还原，分析每一个case下面的代码然后找出对应opcode的顺序。但是这一题我们不用这么麻烦，通过对比分析我们发现普通版的题目并没有修改opcode： 普通版lua引擎的luaV_execute函数 进阶版lua引擎的luaV_execute函数 &emsp;&emsp;观察发现，进阶版的题目只是修改了每个case的数值或者多个值映射到同一个opcode，但是没有打乱case里的代码（也就是说，虚拟机解析opcode代码的顺序没有变，只是修改了对应的数值，这跟梦幻手游的打乱opcode的方法不同）。由于lua5.3只使用到0x2D的opcode，而一个opcode长度为6位（0x3F），该题就将剩余的没有使用的字节映射到同一个opcode下，修复时只需要反过来操作就可以了。分析到这里，我们的修复方案就出来了： 通过ida分别导出2个版本的 luaV_execute 的文本 通过python脚本提取opcode的修复表 在工具（Chunkspy和luadec）初始化lua文件后，用修复表将opcode替换 测试运行，修复其他bug &emsp;&emsp;第一步直接IDA手动导出: File –&gt; Produce file –&gt; Create LST File ；第二步使用python分析，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# 通过扫码IDA导出的文本文件，获取lua字节码的opcode顺序def get_opcode(filepath): f = open(filepath) lines = f.readlines() opcodes = [] # 循环扫码文件的每一行 for i in range(len(lines)): line = lines[i] if line.find('case') != -1: line = line.replace('case', '') line = line.replace(' ', '') line = line.replace('\n','') line = line.replace('u:', '') # 如果上一行也是case，那么这2个case对应同一个opcode if lines[i-1].find('case') != -1: opcode = opcodes[-1] opcode.append(line) else: opcode = [] opcode.append(line) opcodes.append(opcode) f.close() return opcodeso1 = get_opcode(u'基础版opcode.txt')o2 = get_opcode(u'进阶版opcode.txt')# 还原for i in range(len(o1)): print '基础版：',o1[i],'\t进阶版：',o2[i]# 映射opcode获取修复表op_tbl = [-1 for i in range(64)]for i in range(len(o1)): o1opcode = o1[i][0] o1opcode = o1opcode.replace('0x','') for o2opcode in o2[i]: o2opcode = o2opcode.replace('0x','') op_tbl[int(o2opcode,16)] = int(o1opcode,16)print '修复表：',op_tbl &emsp;&emsp;运行结果：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647基础版： ['0'] 进阶版： ['6', '7', '0x16', '0x1B']基础版： ['1'] 进阶版： ['0x22', '0x28', '0x29', '0x3C']基础版： ['2'] 进阶版： ['0x3E']基础版： ['3'] 进阶版： ['0x3B']基础版： ['4'] 进阶版： ['0x12']基础版： ['5'] 进阶版： ['8', '0x11', '0x17', '0x36']基础版： ['6'] 进阶版： ['2']基础版： ['7'] 进阶版： ['0xD']基础版： ['8'] 进阶版： ['0x1A']基础版： ['9'] 进阶版： ['1']基础版： ['0xA'] 进阶版： ['0x1D']基础版： ['0xB'] 进阶版： ['0x1F']基础版： ['0xC'] 进阶版： ['0xE']基础版： ['0xD'] 进阶版： ['0x31']基础版： ['0xE'] 进阶版： ['0x2F']基础版： ['0xF'] 进阶版： ['0x1E']基础版： ['0x12'] 进阶版： ['0x13']基础版： ['0x14'] 进阶版： ['0x2B']基础版： ['0x15'] 进阶版： ['0x1C']基础版： ['0x16'] 进阶版： ['0x2D']基础版： ['0x17'] 进阶版： ['0x19']基础版： ['0x18'] 进阶版： ['0x3F']基础版： ['0x10'] 进阶版： ['0x15']基础版： ['0x13'] 进阶版： ['0x24']基础版： ['0x11'] 进阶版： ['0x3A']基础版： ['0x19'] 进阶版： ['0x18']基础版： ['0x1A'] 进阶版： ['0x33']基础版： ['0x1B'] 进阶版： ['0xF']基础版： ['0x1C'] 进阶版： ['0x34']基础版： ['0x1D'] 进阶版： ['0x20']基础版： ['0x1E'] 进阶版： ['5', '9', '0xA', '0x25']基础版： ['0x1F'] 进阶版： ['0x30']基础版： ['0x20'] 进阶版： ['0x26']基础版： ['0x21'] 进阶版： ['0x35']基础版： ['0x22'] 进阶版： ['0x38']基础版： ['0x23'] 进阶版： ['0x2A']基础版： ['0x24'] 进阶版： ['0x23', '0x37', '0x39', '0x3D']基础版： ['0x25'] 进阶版： ['0x27']基础版： ['0x27'] 进阶版： ['0x2C']基础版： ['0x28'] 进阶版： ['0x32']基础版： ['0x29'] 进阶版： ['0x21']基础版： ['0x2A'] 进阶版： ['3']基础版： ['0x2B'] 进阶版： ['0xC']基础版： ['0x2C'] 进阶版： ['0x2E']基础版： ['0x2D'] 进阶版： ['0x14']基础版： ['0x26'] 进阶版： ['4']修复表： [-1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24] &emsp;&emsp;注意了，这里有几个opcode是没有对应关系的（默认是-1），跟踪代码发现，其实这些opcode的功能相当于nop操作，而原本lua是不存在nop的，我们只需在修复的过程中跳过这个字节码即可。 &emsp;&emsp;最后将获取的修复表替换到工具中，Chunspy修复点在DecodeInst函数中，修改结果如下：12345678910111213141516171819202122232425262728293031323334353637383940function DecodeInst(code, iValues) local iSeq, iMask = config.iABC, config.mABC local cValue, cBits, cPos = 0, 0, 1 -- decode an instruction for i = 1, #iSeq do -- if need more bits, suck in a byte at a time while cBits &lt; iSeq[i] do cValue = string.byte(code, cPos) * (1 &lt;&lt; cBits) + cValue cPos = cPos + 1; cBits = cBits + 8 end -- extract and set an instruction field iValues[config.nABC[i]] = cValue % iMask[i] cValue = cValue // iMask[i] cBits = cBits - iSeq[i] end -- add by littleNA local optbl = &#123; -1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24 &#125; iValues.OP = optbl[iValues.OP+1] -- 注意，lua的下标是从1开始的数起的 -- add by littleNA end iValues.opname = config.opnames[iValues.OP] -- get mnemonic iValues.opmode = config.opmode[iValues.OP] -- add by littleNA if iValues.OP == -1 then iValues.opname = "Nop" iValues.opmode = iABx end -- add by littleNA end if iValues.opmode == iABx then -- set Bx or sBx iValues.Bx = iValues.B * iMask[3] + iValues.C elseif iValues.opmode == iAsBx then iValues.sBx = iValues.B * iMask[3] + iValues.C - config.MAXARG_sBx elseif iValues.opmode == iAx then iValues.Ax = iValues.B * iMask[3] * iMask[2] + iValues.C * iMask[2] + iValues.A end return iValuesend &emsp;&emsp;测试发现出错了，出错结果： &emsp;&emsp;从出错的结果可以看出是luac文件的版本号有错误，这里无法识别lua 11的版本其实是题目故意设计让工具识别错误，我们将文件的第4个字节（lua版本号）11修改成53就可以了。正确结果： &emsp;&emsp;luadec修复点在ldo.c文件的f_parser函数，并且增加一个RepairOpcode函数，修复如下：1234567891011121314151617181920212223242526272829303132333435363738394041// add by littleNAvoid RepairOpcode(Proto* f)&#123; // opcode 替换表 char optbl[] = &#123; -1, 9, 6, 42, 38, 30, 0, 0, 5, 30, 30, -1, 43, 7, 12, 27, -1, 5, 4, 18, 45, 16, 0, 5, 25, 23, 8, 0, 21, 10, 15, 11, 29, 41, 1, 36, 19, 30, 32, 37, 1, 1, 35, 20, 39, 22, 44, 14, 31, 13, 40, 26, 28, 33, 5, 36, 34, 36, 17, 3, 1, 36, 2, 24 &#125;; for (int i = 0; i &lt; f-&gt;sizecode; i++) &#123; Instruction code = f-&gt;code[i]; OpCode o = GET_OPCODE(code); SET_OPCODE(code, optbl[o]); f-&gt;code[i] = code; &#125; for (int i = 0; i &lt; f-&gt;sizep; i++) &#123;// 处理子函数 RepairOpcode(f-&gt;p[i]); &#125;&#125;// add by littleNA endstatic void f_parser (lua_State *L, void *ud) &#123; LClosure *cl; struct SParser *p = cast(struct SParser *, ud); int c = zgetc(p-&gt;z); /* read first character */ if (c == LUA_SIGNATURE[0]) &#123; checkmode(L, p-&gt;mode, "binary"); cl = luaU_undump(L, p-&gt;z, p-&gt;name); // add by littleNA Proto *f = cl-&gt;p; RepairOpcode(f); // add by littleNA end &#125; else &#123; checkmode(L, p-&gt;mode, "text"); cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c); &#125; lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues); luaF_initupvals(L, cl);&#125; &emsp;&emsp;运行一下，发现出错了，并且停留在StringBuffer_add函数中，其中str指向错误的地方，导致字符串读取出错： &emsp;&emsp;到这里我们修复了opcode，并且Chunkspy顺利反汇编，但是luadec的反编译还是有问题，我们在下一节分析。 反编译问题及其修复&emsp;&emsp;看了几个大佬的writeup，发现他们都没有修复这个问题，解题过程中都是直接分析的是lua汇编代码。我们看看出错的原因，查看vs的调用堆栈： &emsp;&emsp;发现上一层函数是listUpvalues函数，也就是说luadec在解析upvalues时出错了，深入分析发现其实是由于文件中的upvalue变量名被抹掉了，导致解析出错，我们只需要在ProcessCode函数（decompile.c文件）调用listUpvalues函数前，增加临时的upvalue命名就可以了，修改代码如下： 123456789101112131415161718char* ProcessCode(Proto* f, int indent, int func_checking, char* funcnumstr) &#123;... // make function comment StringBuffer_printf(str, "-- function num : %s", funcnumstr); if (NUPS(f) &gt; 0) &#123; // add by littleNA for (i = 0; i&lt;f-&gt;sizeupvalues; i++) &#123; char tmp[10]; sprintf(tmp, "up_%d", i); f-&gt;upvalues[i].name = luaS_new(f-&gt;L, tmp); &#125; // add by littleNA end StringBuffer_add(str, " , upvalues : "); listUpvalues(f, str); &#125;...&#125; &emsp;&emsp;最后完美运行luadec，反编译成功。 例子3：梦幻西游手游&emsp;&emsp;这个例子内容较多，并且这篇文章也够长了，索性就把这节单独写成一篇文章。]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密（前传）]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%EF%BC%88%E5%89%8D%E4%BC%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;为了能让一些同学更好的学习lua的逆向，我把收集的一些资料组合成一篇lua加解密的相关工作给大家参考，当然，看这篇文章之前还是需要一些lua的基础知识，这里推荐云风大佬的《Lua源码欣赏》[19]，建议结合搜索引擎学习之。 &emsp;&emsp;文章分2部分介绍，第1部分介绍lua加解密的相关文章介绍，第2部分介绍lua的相关工具。 相关工作：&emsp;&emsp;这一节介绍了互联网上对lua的各种相关文章，包括lua的加解密如文件格式的解析、基于lua的游戏和比赛的介绍、lua的hook技术等。 1. lua加解密入门： &emsp;&emsp;非虫大佬[1-4] 写了4篇关于luac和luajit文件格式和字节码的相关文章，并开源了010Editor的解析luac和luajit的模板代码。Ganlv 同学[7] 在吾爱破解写了7篇关于lua加解密的系列教程。腾讯gslab[9] 写了一篇关于lua游戏逆向的入门介绍，这是一篇比较早的lua游戏解密的文章。INightElf 同学[10] 写了一篇关于lua脚本反编译入门的文章。 2. 基于lua的手游： &emsp;&emsp;lua不仅能用于端游戏，也能用于手游，而且由于手游的火热，带动了lua逆向相关分析文章的分享。wmsuper 同学[11] 在android平台下解密了腾讯游戏开心消消乐的lua脚本，后续可以通过修改lua脚本达到作弊的目的。Unity 同学[8] 通过hook的方法解密和修改lua手游《放置江湖》的流程，达到修改游戏奖励的目的。littleNA 同学[12] 通过3种方式解密了3个手游的lua脚本，并且修复了梦幻手游lua opcode的顺序。 3. 基于lua的比赛： &emsp;&emsp;随着国内CTF的发展，lua技术也运用到了比赛中。看雪ctf2016第2题[13]、2017第15题[14]和腾讯游戏安全2018决赛第2题[15]都使用了lua引擎作为载体的CrackMe比赛，其中看雪2016将算法验证用lua代码实现并编译成luac，最后还修改了luac的文件头，使得反编译工具报错；看雪2017的题使用壳和大量的混淆，最后一步是luajit的简单异或运算；腾讯2018使用的lua技术更加深入，进阶版更是修改了lua的opcode顺序，并使用lua编写了一个虚拟机。以上3题的writeup网上都可以搜索到，有兴趣的朋友可以练练手，加深印象。 4. lua hooking： &emsp;&emsp;Hook是修改软件流程的常用手段，lua中也存在hook技术。曾半仙 同学[9] 在看雪发布了一种通过hook lua字节码达到修改游戏逻辑的方法，并发布了一个lua汇编引擎。Nikc Cano[5] 的blog写了一篇关于Hooking luajit的文章，興趣使然的小胃 同学[6] 对该篇文章进行了翻译。 工具介绍：&emsp;&emsp;逆向解密lua和luajit游戏都有相关的工具，这一节将对一些主流的工具进行介绍。 1. lua相关： luadec [16]：这是一个用c语言结合lua引擎源码写的开源lua反编译器，解析整个lua字节码文件并尽可能的还原为源码。当然，由于还原的是高级语言，所以兼容性一般，当反编译大量文件时肯定会遇到bug，这时就需要自己手动修复bug；并且很容易被针对造成反编译失败。目前支持的版本有lua5.1，5.2和5.3。 chunkspy：一款非常有用的lua分析工具，本身就是lua语言所写。它解析了整个lua字节文件，由于其输出的是lua的汇编形式，所以兼容性非常高，也造成了一定的阅读障碍。chunkspy 不仅可以解析luac文件，它还包括了一个交互式的命令，可以将输入的lua脚本转换成lua字节码汇编的形式，这对学习lua字节码非常有帮助。luadec工具中集成了这个脚本，目前支持的版本也是有lua5.1，5.2和5.3。 unluac：这也是一个开源的lua反编译器，java语言所写，相比luadec 工具兼容性更低,。一般很少使用，只支持lua5.1，当上面工具都失效时可以尝试。 2. luajit相关： luajit-decomp[17]：github开源的一款luajit反编译工具，使用au3语言编写。先通过luajit原生的exe文件将luajit字节码文件转换成汇编，然后该工具再将luajit汇编转换成lua语言。由于反汇编后的luajit字节码缺少很多信息，如变量名、函数名等，造成反编译后的结果读起来比较隐晦，类似于ida的F5。但是兼容性超好，只要能够反汇编就能够反编译，所以使用时需要替换对应版本的luajit引擎（满足反汇编的需求）。目前是支持所有的luajit版本。 ljd[18]：也是github开源的一款luajit反编译工具，使用python编写，与luajit-decomp 反编译luajit汇编的方式不同，其从头解析了整个luajit文件，能够获取更多的信息，还原的程度更高，但是由于精度更高，所以兼容性也会弱一点。查看该项目的fork可以获取更多的其他兼容版本，目前支持的版本有luajit2.0、luajit2.1等。 参考文章 [1] 飞虫 《Lua程序逆向之Luac文件格式分析》 https://www.anquanke.com/post/id/87006 [2] 飞虫 《Lua程序逆向之Luac字节码与反汇编》 https://www.anquanke.com/post/id/87262 [3] 飞虫 《Lua程序逆向之Luajit文件格式》 https://www.anquanke.com/post/id/87281 [4] 飞虫 《Lua程序逆向之Luajit字节码与反汇编》 https://www.anquanke.com/post/id/90241 [5] Nick Cano 《Hooking LuaJIT》 https://nickcano.com/hooking-luajit [6] 興趣使然的小胃 《看我如何通过hook攻击LuaJIT》 https://www.anquanke.com/post/id/86958 [7] Ganlv 《lua脚本解密1：loadstring》 https://www.52pojie.cn/thread-694364-1-1.html [8] unity 《【放置江湖】LUA手游 基于HOOK 解密修改流程》 https://www.52pojie.cn/thread-682778-1-1.html [9] 游戏安全实验室 《Lua游戏逆向及破解方法介绍》 http://gslab.qq.com/portal.php?mod=view&amp;aid=173 [10] INightElf 《[原创]Lua脚本反编译入门之一》 https://bbs.pediy.com/thread-186530.htm [11] wmsuper 《开心消消乐lua脚本解密》 https://www.52pojie.cn/thread-611248-1-1.html [12] littleNA 《浅析android手游lua脚本的加密与解密》 https://bbs.pediy.com/thread-216969.htm [13] 《看雪 2016CrackMe 第二题》 https://ctf.pediy.com/game-fight-3.htm [14] 《看雪 2017CrackMe 第十五题》 https://ctf.pediy.com/game-fight-45.htm [15] 《腾讯游戏安全技术竞赛》 https://www.52pojie.cn/forum-77-1.html [16] luadec https://github.com/viruscamp/luadec [17] ljd https://github.com/NightNord/ljd [18] luajit-decomp https://github.com/bobsayshilol/luajit-decomp [19] 云风 《Lua源码欣赏》 https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/luadec/云风-lua源码欣赏-lua-5.2.pdf]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析android手游lua脚本的加密与解密]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%B5%85%E6%9E%90android%E6%89%8B%E6%B8%B8lua%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;博客刚刚弄完善，把去年发在看雪的一篇精华帖转了过来，文章稍微修改了下，并且增加了后续文章，希望能够吸引点人气。这篇文章是我在学习android手游安全时总结的一篇关于lua的文章，不足之处欢迎指正，也欢迎各位大佬前来交流。 &emsp;&emsp;主要用到的工具和环境： win7系统 cocos2d-x 开发环境 IDA6.8 vs2015 AndroidKiller 1.3.1 luadec51 luajit-decomp… lua 现状分析&emsp;&emsp;去年的那篇文章这一章没有写的，今年补上了一篇lua加解密的相关工作，请看：《浅析android手游lua脚本的加密与解密（前传）》 lua 各文件关系&emsp;&emsp;在学习lua手游解密过程中，遇到的lua文件不外乎就3种。其中.lua后缀的文件是明文代码，直接用记事本就能打开，.luac是lua脚本编译后的字节码文件，文件头为0x1B 0x4C 0x75 0x61，lua虚拟机能够直接解析lua和luac脚本文件，而.luaJIT是另一个lua的实现版本（不是lua的原作者写的），JIT是指Just-In-Time（即时解析运行），luaJIT相比lua和luac更加高效，文件头是0x1B 0x4C 0x4A： &emsp;&emsp;luac 文件头如下： &emsp;&emsp;luaJIT 文件头如下： lua 脚本保护&emsp;&emsp;一般有安全意识的游戏厂商都不会直接把lua源码脚本打包到APK中发布，所以一般对lua脚本的保护有下面3种： 1. 普通的对称加密，在加载脚本之前解密 &emsp;&emsp;这种情况是指打包在APK中的lua代码是加密过的，程序在加载lua脚本时解密（加载脚本的关键函数luaL_loadbuffer），解密后就能够获取lua源码。如果解密后获取的是luac字节码的话，也可以通过对应的反编译得到lua源码，反编译主要用的工具有unluac和luadec51，后面会具体分析。 2. 将lua脚本编译成luaJIT字节码并且加密打包 &emsp;&emsp;因为cocos2d-x使用的luaJIT，而且luaJIT反编译后的结果阅读起来比较麻烦，所以这种情况能够较好的保护lua源码。这个情况主要是先解密后反编译，反编译主要是通过luajit-decomp项目，它能够将luajit字节码反编译成伪lua代码。 3. 修改lua虚拟机中opcode的顺序 &emsp;&emsp;这种情况主要是修改lua虚拟机源码，再通过修改过的虚拟机将lua脚本编译成luac字节码，达到保护的目的。这种情况如果直接用上面的反编译工具是不能将luac反编译的，需要在虚拟机的引擎中分析出相对应的opcode，然后修复反编译工具luadec 源码中的 opcode 并重新编译，编译后的文件就能进行反编译了，后面会具体分析。 &emsp;&emsp;在破解手游过程中，上面的三种情况可能会交叉遇到。 获取lua源码的一般方法&emsp;&emsp;这里主要介绍4种方法，都会在后面用实例说明。 1. 静态分析so解密方法 &emsp;&emsp;这种方法需要把解密的过程全部分析出来，比较费时费力，主要是通过ida定位到luaL_loadbuffer函数，然后往上回溯，分析出解密的过程。 2. 动态调试：ida + idc + dump &emsp;&emsp;游戏会在启动的时候通过调用 luaL_loadbuffer函数加载必要的lua脚本，我们可以通过ida动态调试so文件，然后是定位到luaL_loadbuffer地址，再下断点 ，断下后就接着运行idc脚本（或者python脚本）将lua代码导出（程序调用一次luaL_loadbuffer只加载一个lua脚本，所以需要编写idc脚本自动保存lua代码）。 3. hook so &emsp;&emsp;跟4.2原理一样，就是通过hook函数luaL_loadbuffer地址，将lua代码保存，相比4.2的好处是有些lua脚本需要在玩游戏的过程中才加载，如果用了4.2的方法，那么在游戏过程中需要加载新的lua文件就会中断一次，我们就需要手动运行一次idc脚本，如果是hook的话，就不需要那么麻烦，直接玩一遍游戏，全部lua脚本就已经保存好了。 4. 分析lua虚拟机的opcode的顺序 &emsp;&emsp;这里主要是opcode的顺序被修改了，需要用ida定位到虚拟机执行luac字节码的地方，然后对比原来lua虚拟机的执行过程，获取修改后的opcode顺序，最后还原lua脚本。 &emsp;&emsp;综上，静态分析费时费力但是能够解密全部的lua脚本，而通过动态获取的方法虽然方便，但是只能获取游戏当前需要加载的lua脚本。具体选择哪种方法，需要衡量时间成本等。 lua脚本解密实例分析&emsp;&emsp;接着用3个游戏作为实例说明上面分析的情况。 54捕鱼&emsp;&emsp;首先用AndroidKiller 加载，然后查看lib目录下的so文件，发现libcocos2dlua.so文件，基本可以确定是lua脚本编写的了。这里有个小技巧，当有很多so文件的时候，一般最大的文件是我们的目标（文件大是因为集成了lua引擎，既然有lua引擎，那么肯定有lua脚本了）。接着找lua脚本，资源文件和lua脚本文件都是在assets目录下。我们发现这个游戏的资源文件和配置文件都是明文，这里直接修改游戏的配置文件就可以作弊（比如修改升级炮台所需的金币和钻石，就可以达到快速升级炮台的目的），然后并没有发现类似lua脚本的文件。 &emsp;&emsp;顺手解压了一下res目录下的liveupdate_precompiled.zip，发现解压失败，看来是加密了（看文件名字知道是更新游戏的代码）这里说明一下，一般遇到xxxx_precompiled.zip的这种文件，都是quick-cocos2d-x框架（quick简单来说就是对lua的拓展实现），在quick-cocos2d-x框架下可以用compile_scripts命令将lua文件加密打包成xxxx_precompiled.zip，游戏运行时再解密加载。注意，这种方式打包的lua脚本一般都会被编译成luaJIT字节码，加载的关键函数是loadChunksFromZIP，可以在IDA中直接搜索该函数，如果找不到可以搜索字符串luaLoadChunksFromZIP来定位到函数 &emsp;&emsp;OK，了解了原理接下来开始动手分析，将libcocos2dlua.so拖到IDA中加载，函数中直接搜索loadChunksFromZIP，定位后F5分析。 &emsp;&emsp;对该函数一直向上回溯（交叉引用 ），来到下图，发现解密的密钥和签名，其中xiaoxian为密钥，XXFISH为签名 &emsp;&emsp;进去函数里面看看，其实会发现调用了XXTea算法，这里我们也可以直接分析loadChunksFromZIP函数的源码（所以配置一个cocos2d的开发环境还是非常有必要的）。查看源码里的lua_loadChunksFromZIP函数的原型：12345678910111213141516171819202122232425int CCLuaStack::lua_loadChunksFromZIP(lua_State *L)&#123; if (lua_gettop(L) &lt; 1) &#123; // 这里可以发现用字符串也可以定位到目标函数 CCLOG("lua_loadChunksFromZIP() - invalid arguments"); return 0; &#125;... if (isXXTEA) &#123; // decrypt XXTEA // 这里调用了解密函数 xxtea_long len = 0; buffer = xxtea_decrypt(zipFileData + stack-&gt;m_xxteaSignLen, (xxtea_long)size - (xxtea_long)stack-&gt;m_xxteaSignLen, (unsigned char*)stack-&gt;m_xxteaKey, (xxtea_long)stack-&gt;m_xxteaKeyLen, &amp;len); delete []zipFileData; zipFileData = NULL; zip = CCZipFile::createWithBuffer(buffer, len); &#125;...&#125; &emsp;&emsp;接下来直接写解密函数（在cocos2d-x项目里面写的解密函数，很多工具类直接可以调用）12345678910111213141516171819202122232425262728293031323334353637383940void decryptZipFile_54BY(string strZipFilePath)&#123; CCFileUtils *utils = CCFileUtils::sharedFileUtils(); unsigned long lZipFileSize = 0; unsigned char *szBuffer = NULL; unsigned char *zipFileData = utils-&gt;getFileData(strZipFilePath.c_str(), "rb", &amp;lZipFileSize); xxtea_long xxBufferLen = 0; szBuffer = xxtea_decrypt(zipFileData + 6, //6为签名XXFISH的长度 (xxtea_long)lZipFileSize - (xxtea_long)6, //减去签名的长度 (unsigned char*)"xiaoxian", //xiaoxian为密钥 (xxtea_long)8, //密钥的长度 &amp;xxBufferLen); //获取zip里面的所有文件 CCZipFile *zipFile = CCZipFile::createWithBuffer(szBuffer, xxBufferLen); int count = 0; string strFileName = zipFile-&gt;getFirstFilename(); while (strFileName.length()) &#123; cout &lt;&lt; "filename:" &lt;&lt; strFileName &lt;&lt; endl; unsigned long lFileBufferSize = 0; unsigned char *szFileBuffer = zipFile-&gt;getFileData(strFileName.c_str(), &amp;lFileBufferSize); if (lFileBufferSize) &#123; ++count; ofstream ffout(strFileName, ios::binary); ffout.write((char *)szFileBuffer, sizeof(char) * (lFileBufferSize)); ffout.close(); delete[] szFileBuffer; &#125; strFileName = zipFile-&gt;getNextFilename(); &#125; delete[] zipFileData;&#125; &emsp;&emsp;解密后的文件如下： &emsp;&emsp;这几个都是更新游戏的代码，是luajit的文件，所以接下来需要反编译。反编译需要确定lua和luajit的版本，我们通过IDA查看下lua版本和luajit版本，字符串中分别搜索lua+空格和luajit+空格： &emsp;&emsp;lua版本为5.1 &emsp;&emsp;luajit版本为2.1.0 &emsp;&emsp;这篇文章反编译用到的是luajit-decomp，这里需要注意，luajit-decomp默认的lua 5.1 和luajit 2.0.2，我们需要下载对应lua和luajit的版本，编译后替换luajit-decomp下的lua51.dll、luajit.exe、jit文件夹。反编译时需要替换的文件和文件夹如下： &emsp;&emsp;对于这个游戏，我们需要下载版本为2.1.0-beta2的luajit，并且编译生成文件后，复制LuaJIT-2.1.0-beta2\src路径下的lua51.dll、luajit.exe文件和jit文件夹覆盖到luajit-decomp目录中。luajit-decomp用的是autolt3语言，原脚本默认是只反编译当前目录下的test.lua文件，所以需要修改decoder.au3文件的代码。修改后的代码另存为jitdecomp.au3文件，接着编译au3代码为jitdecomp.exe。我这里还增加了data目录，该目录下有3个文件夹，分别为： luajit：待反编译的luajit文件 asm：反汇编后的中间结果 out：反编译后的结果 &emsp;&emsp;将解密后的文件放到luajit文件夹，运行 jitdecomp.exe，反编译的结果在out目录下，结果如下： &emsp;&emsp;这个反编译工具写得并不好，反编译后的lua文件阅读起来相对比较困难，而且反编译的lua格式有问题，所以不能用lua编辑器格式化代码。 捕鱼达人4&emsp;&emsp;这个游戏主要是用ida动态调试so文件，然后用idc脚本把lua文件全部dump下来的方法。首先用AndroidKiller加载apk，在lib目录下有3个文件夹，不同的手机cpu型号对应不同的文件夹 。本人的手机加载的目标so文件在armeabi-v7a文件下： &emsp;&emsp;接着，ida加载libcocos2dlua.so文件，定位到函数luaL_loadbuffer，可以在函数中直接搜索，也可以字符串搜索 “[LUA ERROR]” 来定位到函数中，函数分析如下： 1LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,const char *name) &emsp;&emsp;所以在ARM汇编中，参数R0为lua_State指针，参数R1为脚本内容，R2为脚本大小，R3为脚本的名称，写一段IDC脚本dump数据即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;idc.idc&gt;static main()&#123; auto code, bp_addrese,fp,strPath,strFileName; bp_addrese = 0x7573022C; // luaL_loadbuffer函数地址 AddBpt(bp_addrese); // 下断点，也可以手动下断 while(1) &#123; code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, 15); // 等待断点发生，等待时间为15秒 if ( code &lt;= 0 ) &#123; Warning("错误代码：%d",code); return 0; &#125; Message ("地址：%a, 事件id：%x\n", GetEventEa(), GetEventId()); // 断点发生，打印消息 strFileName = GetString(GetRegValue("R3"),-1,0); // 获取文件路径名 strFileName = substr(strFileName,strrstr(strFileName,"/")+1,-1); // 获取最后一个‘/’后面的名字（文件的名字）去掉路径 strPath = sprintf("c:\\lua\\%s",strFileName); // 保存lua的本地路径 fp = fopen(strPath,"wb"); savefile(fp,0,GetRegValue("R1"),GetRegValue("R2")); fclose(fp); Message("保存文件成功: %s\n",strPath); &#125;&#125;//字符串查找函数，从后面向前查找，返回第一次查找的字符串下标static strrstr(str,substr1)&#123; auto i,index; index = -1; while (1) &#123; i = strstr(str,substr1); if (-1 == i) return index; str = substr(str,i+1,-1); index = index+i+1; &#125;;&#125; &emsp;&emsp;ida动态调试so文件网上有很多文章，这里就不详细说明了。通过idc脚本获取的部分数据如下： &emsp;&emsp;虽然文件的后缀名是.luac，但其实都是明文的lua脚本。 梦幻西游手游&emsp;&emsp;AndroidKiller反编译apk，查看lib下存在libcocos2dlua.so，基本上确定是lua写的： &emsp;&emsp;在assets\HashRes目录下，存在很多被加密的文件，这里存放的是lua脚本和游戏的其他资源文件： &emsp;&emsp;接着找lua脚本的解密过程，用ida加载libcocos2dlua.so文件，搜索luaL_loadbuffer函数，定位到关键位置，这里就是解密的过程了： &emsp;&emsp;分析解密lua文件过程如下： &emsp;&emsp;这里需要实现Lrc4解密的相关函数，还有Lzma解压函数需要自己实现，其他几个都是cocos2d平台自带的函数，直接调用就可以了。上面的流程图实现的函数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool decryptLua_Mhxy(string strFilePath, string strSaveDir)&#123; bool bResult = false; char *szBuffer = NULL; int nBufferSize = 0; CCFileUtils *utils = CCFileUtils::sharedFileUtils(); unsigned long ulFileSize = 0; char *szFileData = (char*)utils-&gt;getFileData(strFilePath.c_str(), "rb", &amp;ulFileSize); if (strncmp(szFileData, "L:grxx", 6)) &#123; if (!strncmp(szFileData, "__sign_of_g18_enc__", 0x13)) &#123; szBuffer = szFileData + 0x13; nBufferSize = ulFileSize - 0x13; bResult = decrypt((unsigned char*)szBuffer, nBufferSize); &#125; &#125; else if (!strncmp(szFileData + 6, "__sign_of_g18_enc__", 0x13)) &#123; unsigned char *pData = (unsigned char *)szFileData + 0x19; int nLen = ulFileSize - 0x19; bResult = decrypt(pData, nLen); if (ZipUtils::isGZipBuffer(pData, nLen)) &#123; nBufferSize = ZipUtils::ccInflateMemory(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else if (ZipUtils::isCCZBuffer(pData, nLen)) &#123; nBufferSize = ZipUtils::inflateCCZBuffer(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else if (LzmaUtils::isLzmaBuffer(pData, nLen)) &#123; nBufferSize = LzmaUtils::inflateLzmaBuffer(pData, nLen, (unsigned char**)&amp;szBuffer); &#125; else &#123; bResult = false; &#125; &#125; if(bResult) saveLuaData(szBuffer, nBufferSize, strSaveDir); return bResult;&#125; &emsp;&emsp;解密函数过程如下： &emsp;&emsp;decrypt()实现代码如下： 1234567bool decrypt(unsigned char *pData, int nLen)&#123; Lrc4 *pLrc4 = new Lrc4; Lrc4_lrc4(pLrc4); Lrc4_s(pLrc4, pData, nLen); return true;&#125; &emsp;&emsp;Lrc4结构如下: 12345678#define DATA_SIZE 256struct Lrc4&#123; unsigned char pData[DATA_SIZE]; //初始化时计算得到的256个字节 int nIndex; //记录下标 int nPreIndex; //记录前一个下标&#125;; &emsp;&emsp;其他函数的具体实现请看DecryptData_Mhxy.cpp文件，这里就不贴代码了。解密后的文件如下： &emsp;&emsp;可以看出，解密后的文件为luac字节码，但是这里直接用反编译工具是不能反编译luac字节码的，因为游戏的opcode被修改过了，我们需要找到游戏opcode的顺序，然后生成一个对应opcode的luadec.exe文件才能反编译。下表为修改前后的opcode： &emsp;&emsp;lua虚拟机的相关内容就不说明了，百度很多，这里说明下如何还原opcode的顺序。首先需要定位到opmode的地方，IDA搜索字符串”LOADK”，定位到opname的地方，交叉引用到代码，找到opmode： &emsp;&emsp;off_B02CEC为opname的地址，byte_A67C00为opmode的地址，进入opmode地址查看： &emsp;&emsp;这里没有把全部数据截图出来，可以看出，这里的opmode跟原opmode是不对应的。原opmode在lua源码中的lopcodes.c文件中： &emsp;&emsp;源码用了宏，计算出来的结果就是上表中opmode的结果。这里对比opmode就可以快速对比出opcode，因为opmode不相等，那么opcode也肯定不相等，到这一步，已经能还原部分opcode了，因为有一些opmode是唯一的。比如下面几个： &emsp;&emsp;如SETLIST，原opcode为34，opmode为0x14，找到的opmode的第8个字节也为0x14，则实际上SETLIST的opcode为8。 &emsp;&emsp;接下来就需要定位到luaV_execute函数，然后对比源码来还原其他的opcode，直接IDA搜索字符串”initial value must be a number”可以定位到luaV_execute 函数，再F5一下。接着打开lua源码中的lvm.c文件，找到luaV_execute函数，就可对比还原了。lua源码和IDA F5后的代码其实差别还是有的，而且源码用了大量的宏，所以源码只是用来参考、理解lua虚拟机的解析过程，本人在还原的过程中，会再打开一个没有修改opcode的libcocos2dlua.so文件，这样对比查找就方便多了。 &emsp;&emsp;最后修改lua源码 lopcodes.h中的opcode、lopcodes.c的opname和opmode，重新编译并生成luadec51 .exe（需要将lua源码中的src目录放到luadec51的lua目录下才能编译），就OK了，写个批处理文件就可以批量反编译。一个文件反编译的结果： 总结&emsp;&emsp;总结一下解密lua的流程，拿到APK，首先反编译，查看lib目录下是否有libcocos2dlua.so，存在的话很大可能这个游戏就是lua编写，其中lib目录下文件最大的就是目标so文件，一般情况就是libcocos2dlua.so。接着再看assert文件夹有没有可疑的文件，手游的资源文件会放到这个文件夹下，包括lua脚本。其次分析lua加密的方式并选择解密脚本的方式，如果可以ida动态调试，一般都会选择用idc脚本dump下lua代码。最后如果得到的不是lua明文，还需要再反编译一下。 &emsp;&emsp;不足之处：luajit的反编译并不完美，用的是luajit-decomp反编译工具，工具的作者也说只是满足了他自己的需求，还有一个luajit反编译是python写的工具ljd。其次梦幻luac的反编译部分代码反编译失败，修复过程请看这篇文章。 参考文章 腾讯游戏安全中心 《Lua游戏逆向及破解方法介绍》 http://gslab.qq.com/portal.php?mod=view&amp;aid=173 云风 《Lua源码欣赏》 https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/luadec/云风-lua源码欣赏-lua-5.2.pdf FSD-BlueEffie的博客 《梦幻西游手游 美术资源加密分析》 http://blog.csdn.net/blueeffie/article/details/50971665 Kaitiren的专栏 《Quick-cocos2d-x 与Cocos2dx 区别》 http://blog.csdn.net/kaitiren/article/details/35276177]]></content>
      <categories>
        <category>lua加解密</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>luajit</tag>
        <tag>手游安全</tag>
      </tags>
  </entry>
</search>
